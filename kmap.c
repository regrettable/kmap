#include "kmap.h"
// autogenerated binary database file
#include "build/db.h"

#define MaxCharactersInFrame 2048
#define InvalidWordIndex UINT32_MAX
global v4 Transparent = (v4){{0.f, 0.f, 0.f, 0.f}};

global platform_functions Platform = {0};
global debug_queue GlobalDebugQueue = {0};
extern u32 GlobalDebugTimingCount;
global char GlVersionString[] = { '#', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', OPENGL_MAJOR_RELEASE + '0', OPENGL_MINOR_RELEASE + '0', '0', ' ', 'c', 'o', 'r', 'e', '\n', 0 };
global char *GlobalWordFlagNames[] =
{
    [WF_bra] = "Brazilian",
    [WF_hob] = "Hokkaido-ben",
    [WF_ksb] = "Kansai-ben",
    [WF_ktb] = "Kantou_ben",
    [WF_kyb] = "Kyoto-ben",
    [WF_kyu] = "Kyuushuu-ben",
    [WF_nab] = "Nagano-ben",
    [WF_osb] = "Osaka-ben",
    [WF_rkb] = "Ryuukyuu-ben",
    [WF_thb] = "Touhoku-ben",
    [WF_tsb] = "Tosa-ben",
    [WF_tsug] = "Tsugaru-ben",
    [WF_agric] = "agriculture",
    [WF_anat] = "anatomy",
    [WF_archeol] = "archeology",
    [WF_archit] = "architecture",
    [WF_art] = "art, aesthetics",
    [WF_astron] = "astronomy",
    [WF_audvid] = "audiovisual",
    [WF_aviat] = "aviation",
    [WF_baseb] = "baseball",
    [WF_biochem] = "biochemistry",
    [WF_biol] = "biology",
    [WF_bot] = "botany",
    [WF_Buddh] = "Buddhism",
    [WF_bus] = "business",
    [WF_chem] = "chemistry",
    [WF_Christn] = "Christianity",
    [WF_cloth] = "clothing",
    [WF_comp] = "computing",
    [WF_cryst] = "crystallography",
    [WF_ecol] = "ecology",
    [WF_econ] = "economics",
    [WF_elec] = "electricity, elec. eng.",
    [WF_electr] = "electronics",
    [WF_embryo] = "embryology",
    [WF_engr] = "engineering",
    [WF_ent] = "entomology",
    [WF_finc] = "finance",
    [WF_fish] = "fishing",
    [WF_food] = "food, cooking",
    [WF_gardn] = "gardening, horticulture",
    [WF_genet] = "genetics",
    [WF_geogr] = "geography",
    [WF_geol] = "geology",
    [WF_geom] = "geometry",
    [WF_go] = "go (game)",
    [WF_golf] = "golf",
    [WF_gramm] = "grammar",
    [WF_grmyth] = "Greek mythology",
    [WF_hanaf] = "hanafuda",
    [WF_horse] = "horse racing",
    [WF_law] = "law",
    [WF_ling] = "linguistics",
    [WF_logic] = "logic",
    [WF_MA] = "martial arts",
    [WF_mahj] = "mahjong",
    [WF_math] = "mathematics",
    [WF_mech] = "mechanical engineering",
    [WF_med] = "medicine",
    [WF_met] = "meteorology",
    [WF_mil] = "military",
    [WF_music] = "music",
    [WF_ornith] = "ornithology",
    [WF_paleo] = "paleontology",
    [WF_pathol] = "pathology",
    [WF_pharm] = "pharmacy",
    [WF_phil] = "philosophy",
    [WF_photo] = "photography",
    [WF_physics] = "physics",
    [WF_physiol] = "physiology",
    [WF_print] = "printing",
    [WF_psy] = "psychiatry",
    [WF_psych] = "psychology",
    [WF_rail] = "railway",
    [WF_Shinto] = "Shinto",
    [WF_shogi] = "shogi",
    [WF_sports] = "sports",
    [WF_stat] = "statistics",
    [WF_sumo] = "sumo",
    [WF_telec] = "telecommunications",
    [WF_tradem] = "trademark",
    [WF_vidg] = "video games",
    [WF_zool] = "zoology",
    [WF_ateji] = "ateji (phonetic) reading",
    [WF_ke_ik] = "word containing irregular kana usage",
    [WF_ke_iK] = "word containing irregular kanji usage",
    [WF_io] = "irregular okurigana usage",
    [WF_oK] = "word containing out-dated kanji or kanji usage",
    [WF_rK] = "rarely-used kanji form",
    [WF_abbr] = "abbreviation",
    [WF_arch] = "archaism",
    [WF_char] = "character",
    [WF_chn] = "children's language",
    [WF_col] = "colloquialism",
    [WF_company] = "company name",
    [WF_creat] = "creature",
    [WF_dated] = "dated term",
    [WF_dei] = "deity",
    [WF_derog] = "derogatory",
    [WF_doc] = "document",
    [WF_ev] = "event",
    [WF_fam] = "familiar language",
    [WF_fem] = "female term or language",
    [WF_fict] = "fiction",
    [WF_form] = "formal or literary term",
    [WF_given] = "given name or forename, gender not specified",
    [WF_group] = "group",
    [WF_hist] = "historical term",
    [WF_hon] = "honorific or respectful (sonkeigo) language",
    [WF_hum] = "humble (kenjougo) language",
    [WF_id] = "idiomatic expression",
    [WF_joc] = "jocular, humorous term",
    [WF_leg] = "legend",
    [WF_m_sl] = "manga slang",
    [WF_male] = "male term or language",
    [WF_myth] = "mythology",
    [WF_net_sl] = "Internet slang",
    [WF_obj] = "object",
    [WF_obs] = "obsolete term",
    [WF_obsc] = "obscure term",
    [WF_on_mim] = "onomatopoeic or mimetic word",
    [WF_organization] = "organization name",
    [WF_oth] = "other",
    [WF_person] = "full name of a particular person",
    [WF_place] = "place name",
    [WF_poet] = "poetical term",
    [WF_pol] = "polite (teineigo) language",
    [WF_product] = "product name",
    [WF_proverb] = "proverb",
    [WF_quote] = "quotation",
    [WF_rare] = "rare",
    [WF_relig] = "religion",
    [WF_sens] = "sensitive",
    [WF_serv] = "service",
    [WF_sl] = "slang",
    [WF_station] = "railway station",
    [WF_surname] = "family or surname",
    [WF_uk] = "word usually written using kana alone",
    [WF_unclass] = "unclassified name",
    [WF_vulg] = "vulgar expression or word",
    [WF_work] = "work of art, literature, music, etc. name",
    [WF_X] = "rude or X-rated term (not displayed in educational software)",
    [WF_yoji] = "yojijukugo",
    [WF_adj_f] = "noun or verb acting prenominally",
    [WF_adj_i] = "adjective (keiyoushi)",
    [WF_adj_ix] = "adjective (keiyoushi) - yoi/ii class",
    [WF_adj_kari] = "'kari' adjective (archaic)",
    [WF_adj_ku] = "'ku' adjective (archaic)",
    [WF_adj_na] = "adjectival nouns or quasi-adjectives (keiyodoshi)",
    [WF_adj_nari] = "archaic/formal form of na-adjective",
    [WF_adj_no] = "nouns which may take the genitive case particle 'no'",
    [WF_adj_pn] = "pre-noun adjectival (rentaishi)",
    [WF_adj_shiku] = "'shiku' adjective (archaic)",
    [WF_adj_t] = "'taru' adjective",
    [WF_adv] = "adverb (fukushi)",
    [WF_adv_to] = "adverb taking the 'to' particle",
    [WF_aux] = "auxiliary",
    [WF_aux_adj] = "auxiliary adjective",
    [WF_aux_v] = "auxiliary verb",
    [WF_conj] = "conjunction",
    [WF_cop] = "copula",
    [WF_ctr] = "counter",
    [WF_exp] = "expressions (phrases, clauses, etc.)",
    [WF_int] = "interjection (kandoushi)",
    [WF_n] = "noun (common) (futsuumeishi)",
    [WF_n_adv] = "adverbial noun (fukushitekimeishi)",
    [WF_n_pr] = "proper noun",
    [WF_n_pref] = "noun, used as a prefix",
    [WF_n_suf] = "noun, used as a suffix",
    [WF_n_t] = "noun (temporal) (jisoumeishi)",
    [WF_num] = "numeric",
    [WF_pn] = "pronoun",
    [WF_pref] = "prefix",
    [WF_prt] = "particle",
    [WF_suf] = "suffix",
    [WF_unc] = "unclassified",
    [WF_v_unspec] = "verb unspecified",
    [WF_v1] = "Ichidan verb",
    [WF_v1_s] = "Ichidan verb - kureru special class",
    [WF_v2a_s] = "Nidan verb with 'u' ending (archaic)",
    [WF_v2b_k] = "Nidan verb (upper class) with 'bu' ending (archaic)",
    [WF_v2b_s] = "Nidan verb (lower class) with 'bu' ending (archaic)",
    [WF_v2d_k] = "Nidan verb (upper class) with 'dzu' ending (archaic)",
    [WF_v2d_s] = "Nidan verb (lower class) with 'dzu' ending (archaic)",
    [WF_v2g_k] = "Nidan verb (upper class) with 'gu' ending (archaic)",
    [WF_v2g_s] = "Nidan verb (lower class) with 'gu' ending (archaic)",
    [WF_v2h_k] = "Nidan verb (upper class) with 'hu/fu' ending (archaic)",
    [WF_v2h_s] = "Nidan verb (lower class) with 'hu/fu' ending (archaic)",
    [WF_v2k_k] = "Nidan verb (upper class) with 'ku' ending (archaic)",
    [WF_v2k_s] = "Nidan verb (lower class) with 'ku' ending (archaic)",
    [WF_v2m_k] = "Nidan verb (upper class) with 'mu' ending (archaic)",
    [WF_v2m_s] = "Nidan verb (lower class) with 'mu' ending (archaic)",
    [WF_v2n_s] = "Nidan verb (lower class) with 'nu' ending (archaic)",
    [WF_v2r_k] = "Nidan verb (upper class) with 'ru' ending (archaic)",
    [WF_v2r_s] = "Nidan verb (lower class) with 'ru' ending (archaic)",
    [WF_v2s_s] = "Nidan verb (lower class) with 'su' ending (archaic)",
    [WF_v2t_k] = "Nidan verb (upper class) with 'tsu' ending (archaic)",
    [WF_v2t_s] = "Nidan verb (lower class) with 'tsu' ending (archaic)",
    [WF_v2w_s] = "Nidan verb (lower class) with 'u' ending and 'we' conjugation (archaic)",
    [WF_v2y_k] = "Nidan verb (upper class) with 'yu' ending (archaic)",
    [WF_v2y_s] = "Nidan verb (lower class) with 'yu' ending (archaic)",
    [WF_v2z_s] = "Nidan verb (lower class) with 'zu' ending (archaic)",
    [WF_v4b] = "Yodan verb with 'bu' ending (archaic)",
    [WF_v4g] = "Yodan verb with 'gu' ending (archaic)",
    [WF_v4h] = "Yodan verb with 'hu/fu' ending (archaic)",
    [WF_v4k] = "Yodan verb with 'ku' ending (archaic)",
    [WF_v4m] = "Yodan verb with 'mu' ending (archaic)",
    [WF_v4n] = "Yodan verb with 'nu' ending (archaic)",
    [WF_v4r] = "Yodan verb with 'ru' ending (archaic)",
    [WF_v4s] = "Yodan verb with 'su' ending (archaic)",
    [WF_v4t] = "Yodan verb with 'tsu' ending (archaic)",
    [WF_v5aru] = "Godan verb - -aru special class",
    [WF_v5b] = "Godan verb with 'bu' ending",
    [WF_v5g] = "Godan verb with 'gu' ending",
    [WF_v5k] = "Godan verb with 'ku' ending",
    [WF_v5k_s] = "Godan verb - Iku/Yuku special class",
    [WF_v5m] = "Godan verb with 'mu' ending",
    [WF_v5n] = "Godan verb with 'nu' ending",
    [WF_v5r] = "Godan verb with 'ru' ending",
    [WF_v5r_i] = "Godan verb with 'ru' ending (irregular verb)",
    [WF_v5s] = "Godan verb with 'su' ending",
    [WF_v5t] = "Godan verb with 'tsu' ending",
    [WF_v5u] = "Godan verb with 'u' ending",
    [WF_v5u_s] = "Godan verb with 'u' ending (special class)",
    [WF_v5uru] = "Godan verb - Uru old class verb (old form of Eru)",
    [WF_vi] = "intransitive verb",
    [WF_vk] = "Kuru verb - special class",
    [WF_vn] = "irregular nu verb",
    [WF_vr] = "irregular ru verb, plain form ends with -ri",
    [WF_vs] = "noun or participle which takes the aux. verb suru",
    [WF_vs_c] = "su verb - precursor to the modern suru",
    [WF_vs_i] = "suru verb - included",
    [WF_vs_s] = "suru verb - special class",
    [WF_vt] = "transitive verb",
    [WF_vz] = "Ichidan verb - zuru verb (alternative form of -jiru verbs)",
    [WF_gikun] = "gikun (meaning as reading) or jukujikun (special kanji reading)",
    [WF_ik] = "word containing irregular kana usage",
    [WF_ok] = "out-dated or obsolete kana usage",
    [WF_uK] = "word usually written using kanji alone",
};

typedef struct
{
    u8 MinimumValue, MaximumValue;
    char *Description;
} word_flag_type;

global word_flag_type GlobalFlagTypes[] =
{
    { .MinimumValue = WF_adj_f, .MaximumValue = WF_vz, .Description = "Part of speech:" },
    { .MinimumValue = WF_bra, .MaximumValue = WF_tsug, .Description = "Dialect:" },
    { .MinimumValue = WF_agric, .MaximumValue = WF_zool, .Description = "Field:" },
    { .MinimumValue = WF_ateji, .MaximumValue = WF_rK, .Description = "Kanji info:" },
    { .MinimumValue = WF_gikun, .MaximumValue = WF_uK, .Description = "Reading info:" },
    { .MinimumValue = WF_abbr, .MaximumValue = WF_yoji,  .Description = "Other info:" },
};

// NOTE: used for debugging
#define WHITE V3(1.f, 1.f, 1.f)
#define BLACK V3(0.f, 0.f, 0.f)
#define BLUE V3(0.f, 0.f, 1.f)
#define RED V3(1.f, 0.f, 0.f)
#define GREEN V3(0.f, 1.f, 0.f)
#define CYAN V3(0.f, 1.f, 1.f)
#define PINK V3(1.f, 0.f, 1.f)
#define YELLOW V3(1.f, 1.f, 0.f)

#define IsPrintableAscii(Codepoint) ((Codepoint >= ' ') && (Codepoint <= '~'))
#define UiCharacterCount (('~' - ' ') + (L'ヽ' - L'ぁ') + 2)

// NOTE: TA = Texture Atlas
#define TACellsPerSide 64
#define TACellCount (TACellsPerSide*TACellsPerSide)

StaticAssert(TACellCount > UiCharacterCount);

#define TACellSize (TACellSide*TACellSide)
#define TASide (TACellSide*TACellsPerSide)

#define UseShader(ProgramName) glUseProgram(ShaderPrograms[ProgramName].Handle)

#define REFERENCE_CACHE_MAGIC (('K' << 24) | ('R' << 16) | ('F' << 8) | ('C'))
#define REFERENCE_CACHE_VERSION 1

typedef struct
{
    u64 Rng;
    v2 CameraPos;
    u32 ReferenceCount;
} reference_layer;

#define ReferenceLayerCount 10

typedef struct
{
    u32 Magic;
    u32 Version;
    u32 WordCount;
    u32 FontNameHash;
    reference_layer Layers[ReferenceLayerCount];
} reference_cache_header;

typedef struct
{
    u32 WordIndex;
    v2 KanjiPosition;
} line_data;

typedef struct
{
    memory_arena Arena;
    memory_arena FrameArena;
    memory_arena WordArena; // where words are stored
    memory_arena SearchArena; // stores search results only, reset when the search is reset

    f32 LastFrameTime;
    v2 LastFrameMousePos;

    camera Camera;

    load_file_result FontFile;
    stbtt_fontinfo Font;
    f32 LargestFontScale;
    f32 UiTextScale;

    u32 WordCount;
    word *Words;
    char *WordData;

    GLuint TextVAO;
    GLuint TextVBO;

    struct
    {
        ta_cell *Cells;
        GLuint Texture;
    } TA;

    GLuint TextBackgroundVAO;
    GLuint TextBackgroundVBO;

    GLuint LineVAO;
    GLuint LineVBO;
    u32 LineCount;

    u32 SelectedWordPosition;
    line_data *Lines;
    c32 SelectedCodepoint;

    b32 UsingLightTheme;
    theme Theme;

    kanji_hashtable KanjiHashtable;

    u32 InputFieldCursorPosition;
    codepoints InputField;

    u32 SearchResultCount;
    u32 SearchResultPos;
    u32 *SearchResultIndices;

    // NOTE: the bookmarks are implemented through the use of these reference layers.
    // This way the word can be positioned in multiple different places at the same time.
    u32 MainLayerIndex;
    u32 SecondaryLayerIndex;

    reference_cache_header *ReferenceHeader;
    word_reference *ReferenceData;

    b32 ShouldShowKanjiOverlay;
    b32 Initialized;
} kmap_state;

internal GLuint
DebugLoadShader(char *Path, GLenum Type, char **IncludePaths)
{
    char FullPath[512] = SHADERS_PATH;
    size_t PathLength = CopyStringLen(Path, FullPath + sizeof(SHADERS_PATH) - 1, ArrayCount(FullPath));
    Assert(PathLength < (ArrayCount(FullPath) - 1));
    u32 IncludeCount = 0;
    for(char *Include = IncludePaths[0];
        Include;
        ++IncludeCount, Include = IncludePaths[IncludeCount]) {}

    GLuint Shader = 0;
    b32 LoadedSuccessfully = false;
    while(!LoadedSuccessfully)
    {
        u32 ShaderSourceCount = 2 + IncludeCount;
        load_file_result MainSource = Platform.LoadFile(FullPath, true);

        char *ShaderSources[ShaderSourceCount];
        load_file_result AdditionalSources[IncludeCount];
        ShaderSources[0] = GlVersionString;
        for(u32 IncludeIndex = 0; IncludeIndex < IncludeCount; ++IncludeIndex)
        {
            char IncludeFullPath[512] = SHADERS_PATH;
            size_t PathLength = CopyStringLen(IncludePaths[IncludeIndex], IncludeFullPath + sizeof(SHADERS_PATH) - 1, ArrayCount(FullPath));
            Assert(PathLength < (ArrayCount(FullPath) - 1));

            AdditionalSources[IncludeIndex] = Platform.LoadFile(IncludeFullPath, true);
            ShaderSources[IncludeIndex + 1] = AdditionalSources[IncludeIndex].Data;
        }
        ShaderSources[ShaderSourceCount - 1] = MainSource.Data;

        Shader = glCreateShader(Type);
        glShaderSource(Shader, ShaderSourceCount, (const char * const *)ShaderSources, 0);
        glCompileShader(Shader);

        glGetShaderiv(Shader, GL_COMPILE_STATUS, &LoadedSuccessfully);
        if(!LoadedSuccessfully)
        {
            GLchar InfoLog[512];
            glGetShaderInfoLog(Shader, 512, 0, InfoLog);
            eprintf("(%s): %s\n", FullPath, InfoLog);
            glDeleteShader(Shader);
            Platform.Sleep(1);
        }

        Platform.UnloadFile(MainSource);
        for(u32 IncludeIndex = 0; IncludeIndex < IncludeCount; ++IncludeIndex)
        {
            Platform.UnloadFile(AdditionalSources[IncludeIndex]);
        }
    }
    return Shader;
}

internal void
DebugCreateShaderProgram(shader_program_description *ProgramDescription)
{
    b32 LinkSuccess = false;
    while(!LinkSuccess)
    {
        GLuint ShaderProgram = glCreateProgram();

        GLuint VertexShader = 0,
               FragmentShader = 0;

        VertexShader = DebugLoadShader(ProgramDescription->VertexPath, GL_VERTEX_SHADER, ProgramDescription->VertexIncludes);
        glAttachShader(ShaderProgram, VertexShader);

        FragmentShader = DebugLoadShader(ProgramDescription->FragmentPath, GL_FRAGMENT_SHADER, ProgramDescription->FragmentIncludes);
        glAttachShader(ShaderProgram, FragmentShader);

        glLinkProgram(ShaderProgram);

        glGetProgramiv(ShaderProgram, GL_LINK_STATUS, &LinkSuccess);
        if(!LinkSuccess)
        {
            GLchar InfoLog[512];
            glGetProgramInfoLog(ShaderProgram, 512, 0, InfoLog);
            eprintf("Linking the shaders failed with %s\n", InfoLog);
            glDeleteProgram(ShaderProgram);
            Platform.Sleep(1);
        }
        else
        {
            ProgramDescription->Handle = ShaderProgram;
        }

        glDeleteShader(FragmentShader);
        glDeleteShader(VertexShader);
    }
}

internal GLuint
ReleaseLoadShader(char *Data, GLenum Type)
{
    GLuint Result = glCreateShader(Type);
    char *Strings[2] = { GlVersionString, Data };
    glShaderSource(Result, 2, (const GLchar * const *)Strings, 0);
    glCompileShader(Result);
    b32 LoadedSuccessfully = true;
    glGetShaderiv(Result, GL_COMPILE_STATUS, &LoadedSuccessfully);
    Assert(LoadedSuccessfully);
    return Result;
}

internal void
DebugDrawPointSize(v2 PixelCoordinates, f32 PixelSide, v3 Color)
{
#if DEBUG_INFO
    Assert(GlobalDebugQueue.SquareCount < ArrayCount(GlobalDebugQueue.Squares));
    square Square =
    {
        .Coordinates = V3(PixelCoordinates.x, PixelCoordinates.y, PixelSide),
        .Color = Color
    };
    GlobalDebugQueue.Squares[GlobalDebugQueue.SquareCount] = Square;
    GlobalDebugQueue.SquareCount++;

    // TODO: we should try do the debug pass whenever queue gets filled up,
    // but that would interfere with the regular drawing...
#endif
}

#define DebugDrawPoint(PixelCoordinates, Color) DebugDrawPointSize((PixelCoordinates), 2.f, (Color))

// same formula as in the shader
internal v2
WorldToScreenSpace(v2 WorldPos, camera Camera)
{
    v2 CameraCorrected = V2TimesScalar(V2Sub(WorldPos, Camera.Pos), Camera.Zoom);
    v2 ScreenSpace = V2Hadamard(CameraCorrected, V2Inv(V2TimesScalar(Camera.Dim, .5f)));
    return ScreenSpace;
}

internal v2
WorldToPixelSpace(v2 WorldPos, camera Camera)
{
    v2 Result = V2Sub(WorldPos, Camera.Pos);
    Result = V2TimesScalar(Result, Camera.Zoom);
    Result = V2Add(Result, V2TimesScalar(Camera.Dim, .5f));
    return Result;
}

// inverse of the above
internal v2
PixelToWorldSpace(v2 PixelSpace, camera Camera)
{
    v2 Result = V2Sub(PixelSpace, V2TimesScalar(Camera.Dim, .5f));
    Result = V2TimesScalar(Result, 1.f / Camera.Zoom);
    Result = V2Add(Result, Camera.Pos);
    return Result;
}

// incorrect
internal v2
PixelToScreenSpace(v2 PixelSpace, camera Camera)
{
    v2 Result = V2Sub(V2TimesScalar(V2Hadamard(PixelSpace, V2Inv(Camera.Dim)),
                                    2.f),
                      V2(1.f, 1.f));
    return Result;
}

internal void
DebugDrawPointSizeWorld(camera Camera, v2 WorldCoordinates, f32 Side, v3 Color)
{
    v2 PixelCoordinates = WorldToPixelSpace(WorldCoordinates, Camera);
    DebugDrawPointSize(PixelCoordinates, Side, Color);
}

#define DebugDrawPointWorld(Camera, WorldCoordinates, Color) DebugDrawPointSizeWorld((Camera), (WorldCoordinates), 2.f, (Color))

void APIENTRY 
GLDebugCallback(GLenum source, GLenum type, unsigned int id, GLenum severity,
                GLsizei length, const char *message, const void *userParam)
{
    eprintf("[OPENGL]: %.*s\n", length, message);
}

internal void
ChangeTheme(kmap_state *State, theme NewTheme)
{
    State->Theme = NewTheme;
    UseShader(SP_TextBackground);
    glClearColor(NewTheme.Colors[CT_Background].r,
                 NewTheme.Colors[CT_Background].g,
                 NewTheme.Colors[CT_Background].b, 1.f);
    glUniform4f(glGetUniformLocation(ShaderPrograms[SP_TextBackground].Handle, "BackgroundColor"), 
                NewTheme.Colors[CT_Background].r,
                NewTheme.Colors[CT_Background].g,
                NewTheme.Colors[CT_Background].b,
                NewTheme.Colors[CT_Background].a);
    glUniform1f(glGetUniformLocation(ShaderPrograms[SP_TextBackground].Handle, "HighlightedBorderWidth"), 
                NewTheme.UiBorderWidth);
    glUniform1f(glGetUniformLocation(ShaderPrograms[SP_TextBackground].Handle, "DictionaryEntryPadding"), NewTheme.DictionaryEntryPadding);

    UseShader(SP_Lines);
    glUniform4f(glGetUniformLocation(ShaderPrograms[SP_Lines].Handle, "Color1"), 
                NewTheme.Colors[CT_Line1].r,
                NewTheme.Colors[CT_Line1].g,
                NewTheme.Colors[CT_Line1].b,
                NewTheme.Colors[CT_Line1].a);
    glUniform4f(glGetUniformLocation(ShaderPrograms[SP_Lines].Handle, "Color2"), 
                NewTheme.Colors[CT_Line2].r,
                NewTheme.Colors[CT_Line2].g,
                NewTheme.Colors[CT_Line2].b,
                NewTheme.Colors[CT_Line2].a);
    glUniform1f(glGetUniformLocation(ShaderPrograms[SP_Lines].Handle, "LineWidthInPixels"), NewTheme.LineWidth);
    UseShader(SP_Background);
    glUniform4f(glGetUniformLocation(ShaderPrograms[SP_Background].Handle, "Color1"),
                NewTheme.Colors[CT_Background].r,
                NewTheme.Colors[CT_Background].g,
                NewTheme.Colors[CT_Background].b,
                NewTheme.Colors[CT_Background].a);
    glUniform4f(glGetUniformLocation(ShaderPrograms[SP_Background].Handle, "Color2"),
                NewTheme.Colors[CT_Text].r,
                NewTheme.Colors[CT_Text].g,
                NewTheme.Colors[CT_Text].b,
                NewTheme.Colors[CT_Text].a);
}

internal void
ChangeLineCenter(v2 NewCenter)
{
    GLuint LineProgram = ShaderPrograms[SP_Lines].Handle;
    glUseProgram(LineProgram);
    glUniform2f(glGetUniformLocation(LineProgram, "FirstPositionWorld"), NewCenter.x, NewCenter.y);
}


// NOTE: state has to be initialized before this is called!
RELOAD_SHADERS(ReloadShaders)
{
    kmap_state *State = (kmap_state *)Memory->Base;
    for(size_t ShaderProgramIndex = 0;
        ShaderProgramIndex < ArrayCount(ShaderPrograms);
        ++ShaderProgramIndex)
    {
        shader_program_description *Prog = ShaderPrograms + ShaderProgramIndex;
        glDeleteProgram(Prog->Handle);
        DebugCreateShaderProgram(Prog);
    }

    ChangeTheme(State, State->UsingLightTheme ? LightTheme : DarkTheme);
    if(State->Lines && State->SelectedWordPosition != UINT32_MAX)
    {
        line_data *Line = State->Lines + State->SelectedWordPosition;
        ChangeLineCenter(Line->KanjiPosition);
    }
}

// NOTE: state has to be initialized before this is called!
FINISH_WORK(FinishWork)
{
    kmap_state *State = (kmap_state *)Memory->Base;
    for(size_t ShaderProgramIndex = 0;
        ShaderProgramIndex < ArrayCount(ShaderPrograms);
        ++ShaderProgramIndex)
    {
        glDeleteProgram(ShaderPrograms[ShaderProgramIndex].Handle);
    }
    glDeleteTextures(1, &State->TA.Texture);
    Platform.UnloadFile(State->FontFile);
    ResetArena(&State->Arena);
    State->Initialized = false;
}

internal rect
GetWordBoundingBox(kmap_state *State, u32 WordIndex)
{
    rect Result = {0};
    reference_layer *CurrentLayer = State->ReferenceHeader->Layers + State->MainLayerIndex; 
    word_reference *References = State->ReferenceData + (State->MainLayerIndex * State->WordCount);
    if(State->MainLayerIndex == 0)
    {
        Result = References[WordIndex].BoundingBox;
    }
    else
    {
        for(u32 ThisReferenceIndex = 0; ThisReferenceIndex < CurrentLayer->ReferenceCount; ++ThisReferenceIndex)
        {
            word_reference *Reference = References + ThisReferenceIndex;
            if(Reference->WordIndex == WordIndex)
            {
                Result = Reference->BoundingBox;
                break;
            }
        }
    }
    return Result;
}

internal kanji_data
KanjiInfoToKanjiData(kanji_hashtable *Hashtable, kanji_info *Storage)
{
    kanji_data Result = 
    {
        .WordIndices = (u32 *)(Hashtable->Data + Storage->WordIndexOffset),
        .WordCount = Storage->WordIndexCount,
        .OnReadingCount = Storage->OnReadingCount,
        .KunReadingCount = Storage->KunReadingCount,
        .MeaningCount = Storage->MeaningCount,
        .RadicalCount = Storage->RadicalCount,
        .SimilarKanjiCount = Storage->SimilarKanjiCount,
        .FrequentlyUsedWordCount = Storage->FrequentlyUsedWordCount,
        .OnReadings = (char *)(Hashtable->Data + Storage->OnReadingOffset),
        .KunReadings = (char *)(Hashtable->Data + Storage->KunReadingOffset),
        .Meanings = (char *)(Hashtable->Data + Storage->MeaningOffset),
        .Radicals = (c32 *)(Hashtable->Data + Storage->RadicalOffset),
        .SimilarKanji = (c32 *)(Hashtable->Data + Storage->SimilarKanjiOffset),
        .FrequentlyUsedWordIndices = (u32 *)(Hashtable->Data + Storage->FrequentlyUsedWordIndexOffset)
    };
    return Result;
}

// open addressing scheme
internal kanji_data
GetKanjiData(kanji_hashtable *Hashtable, c32 Codepoint)
{
    StartTimingFunc();
    kanji_data Result = {0};
    u16 Hash = GetKanjiHash(Codepoint);
    for(u32 StorageIndex = Hash;
        StorageIndex < Hashtable->KanjiCount;
        ++StorageIndex)
    {
        kanji_info *Storage = Hashtable->KanjiInfos + StorageIndex;
        Assert((Storage->Codepoint == 0) || IsKanji(Storage->Codepoint));
        if(Storage->Codepoint == Codepoint)
        {
            Result = KanjiInfoToKanjiData(Hashtable, Storage);
            break;
        }
    }
    EndTimingFunc();
    return Result;
}

internal void
SetupGlyph(stbtt_fontinfo *Font, f32 FontScale, memory_arena *Arena, u32 CellIndex, u32 Codepoint, ta_cell *Cell)
{
    glyph Glyph = {0};
    temp_memory TempMemory = BeginTempMemory(Arena);

    u32 CellX = CellIndex % TACellsPerSide;
    u32 CellY = CellIndex / TACellsPerSide;

    u32 GlyphIndex = stbtt_FindGlyphIndex(Font, Codepoint);

    stbtt_GetGlyphBitmapBox(Font, GlyphIndex, FontScale, FontScale, &Glyph.X0, &Glyph.Y0, &Glyph.X1, &Glyph.Y1);

    // NOTE: since we have multiple font sizes, we need to know the scale to render properly.
    Cell->Scale = FontScale;
    int AtlasX = CellX * TACellSide;
    int AtlasY = CellY * TACellSide;
    Glyph.AtlasTopLeft = V2(AtlasX, AtlasY);

    int Lsb;
    stbtt_GetGlyphHMetrics(Font, GlyphIndex, &Glyph.Advance, &Lsb);
    int Width = Glyph.X1 - Glyph.X0;
    int Height = Glyph.Y1 - Glyph.Y0;
    u8 *GlyphData = PushSize(TempMemory.Arena, TACellSize);
    stbtt_MakeGlyphBitmap(Font, GlyphData, TACellSide, TACellSide, Width, FontScale, FontScale, GlyphIndex);
    glTexSubImage2D(GL_TEXTURE_2D, 0, AtlasX, AtlasY, Width, Height, GL_RED, GL_UNSIGNED_BYTE, GlyphData);

    EndTempMemory(TempMemory);

    Cell->IsOccupied = true;
    Cell->IsLocked = true;
    Cell->Recency = 0;
    Cell->Codepoint = Codepoint;
    Cell->Glyph = Glyph;
}

internal f32
GetCharacterCenter(stbtt_fontinfo *Font,
                   f32 FontScale,
                   codepoints *Codepoints,
                   u32 CharacterIndex)
{
    int XPos = 0;
    Assert(CharacterIndex < Codepoints->Count);
    int GlyphIndex = 0,
        NextGlyphIndex = stbtt_FindGlyphIndex(Font, Codepoints->Data[0]);
    int Advance = 0, LSB;
    for(u32 CodepointIndex = 0;
        CodepointIndex < CharacterIndex;
        ++CodepointIndex)
    {
        GlyphIndex = NextGlyphIndex;
        NextGlyphIndex = stbtt_FindGlyphIndex(Font, Codepoints->Data[CodepointIndex + 1]);
        int Kerning = stbtt_GetGlyphKernAdvance(Font, GlyphIndex, NextGlyphIndex);
        stbtt_GetGlyphHMetrics(Font, GlyphIndex, &Advance, &LSB);
        XPos += Kerning + Advance;
    }
    f32 Result = FontScale * (XPos + (Advance * .5f));
    return Result;
}

internal glyph
GetOrMakeCodepointGlyph(kmap_state *State, c32 Codepoint, f32 Scale)
{
    StartTimingFunc();
    u32 UsedCellIndex = UINT32_MAX;
    if((Scale == State->UiTextScale) && (IsKana(Codepoint) || IsPrintableAscii(Codepoint)))
    {
        for(u32 CellIndex = 0; CellIndex < UiCharacterCount; ++CellIndex)
        {
            ta_cell *Cell = State->TA.Cells + CellIndex;
            if(Cell->IsOccupied && Cell->Codepoint == Codepoint)
            {
                Assert(Cell->IsOccupied);
                //Cell->IsLocked = true;
                UsedCellIndex = CellIndex;
                break;
            }
        }
        Assert(UsedCellIndex != UINT32_MAX);
    }
    else
    {
        // in case scale is too large, don't render correctly and use the largest size instead
        if(Scale > State->LargestFontScale)
        {
            Scale = State->LargestFontScale;
        }

        for(u32 CellIndex = UiCharacterCount;
            CellIndex < TACellCount;
            ++CellIndex)
        {
            ta_cell *Cell = State->TA.Cells + CellIndex;
            if((Cell->IsOccupied) && (Cell->Codepoint == Codepoint) && (Cell->Scale == Scale))
            {
                Cell->IsLocked = true;
                UsedCellIndex = CellIndex;
                goto FoundCell;
            }
        }

        // not in the cache, rasterize and put in there
        {
            for(u32 CellIndex = UiCharacterCount;
                CellIndex < TACellCount;
                ++CellIndex)
            {
                ta_cell *Cell = State->TA.Cells + CellIndex;
                if(!Cell->IsOccupied)
                {
                    UsedCellIndex = CellIndex;
                    goto SetupCell;
                }
                else if(!Cell->IsLocked)
                {
                    Cell->Recency++;
                }
            }

            // no unoccupied cells, have to unload something
            u32 HighestRecency = 0;

            for(u32 CellIndex = UiCharacterCount;
                CellIndex < TACellCount;
                ++CellIndex)
            {
                ta_cell *Cell = State->TA.Cells + CellIndex;
                if(!Cell->IsLocked)
                {
                    if(Cell->Recency > HighestRecency)
                    {
                        UsedCellIndex = CellIndex;
                        HighestRecency = Cell->Recency;
                    }
                }
            }

            // we don't support the situation where everything is locked
            Assert(UsedCellIndex != UINT32_MAX);

SetupCell:
            ta_cell *UsedCell = State->TA.Cells + UsedCellIndex;
            SetupGlyph(&State->Font, Scale, &State->FrameArena, UsedCellIndex, Codepoint, UsedCell);
        }
    }

FoundCell:
    ta_cell *UsedCell = State->TA.Cells + UsedCellIndex;
    glyph Result = UsedCell->Glyph;
    EndTimingFunc();
    return Result;
}

internal void
SelectKanjiAndDrawLines(kmap_state *State, u32 WordIndex, c32 Codepoint)
{
    StartTimingFunc();
    Assert(IsKanji(Codepoint));
    reference_layer *CurrentLayer = State->ReferenceHeader->Layers + State->MainLayerIndex;

    // NOTE: we first save the indices of the words that have
    // our kanji, and then buffer their positions
    memory_arena *PermArena = &State->WordArena;
    ResetArena(PermArena);

    State->SelectedWordPosition = UINT32_MAX;
    State->SelectedCodepoint = 0;
    word_reference *References = State->ReferenceData + (State->MainLayerIndex * State->WordCount);
    State->Lines = StartDynamicArray(PermArena, line_data);
    for(u32 ReferenceIndex = 0; ReferenceIndex < CurrentLayer->ReferenceCount; ++ReferenceIndex)
    {
        word_reference *Reference = References + ReferenceIndex;

        u32 ThisWordIndex = Reference->WordIndex;
        word *ThisWord = State->Words + ThisWordIndex;
        codepoints Writing = ConvertToCodepoints(ThisWord->Writing);
        for(u32 CodepointIndex = 0; CodepointIndex < Writing.Count; ++CodepointIndex)
        {
            if(Writing.Data[CodepointIndex] == Codepoint)
            {
                line_data LineData;
                LineData.WordIndex = ThisWordIndex;
                if(ThisWordIndex == WordIndex)
                {
                    State->SelectedWordPosition = PermArena->ArrayCount;
                }

                rect BoundingBox = Reference->BoundingBox;
                //  0 1 2 3
                // | | | | |
                //  ^ ^ ^ ^
                //  1 3 5 7
                //  - - - -
                //  8 8 8 8
                f32 LerpC = (1.f / (Writing.Count * 2.f)) + ((f32)CodepointIndex / (f32)Writing.Count);
                v2 KanjiPosition =
                {
                    .x = Lerp(BoundingBox.BottomLeft.x, BoundingBox.TopRight.x, LerpC),
                    .y = (BoundingBox.BottomLeft.y + BoundingBox.TopRight.y) * .5f
                };
                LineData.KanjiPosition = KanjiPosition;
                PushElement(PermArena, LineData);

                //
                break;
            }
        }
    }
    u32 LineCount = EndDynamicArray(PermArena);

    // NOTE: we are drawing one extra line from the selected word to itself
    if(LineCount)
    {
        Assert(State->SelectedWordPosition != UINT32_MAX);

        v2 Center = State->Lines[State->SelectedWordPosition].KanjiPosition;
        ChangeLineCenter(Center);
        glBindVertexArray(State->LineVAO);
        glBindBuffer(GL_ARRAY_BUFFER, State->LineVBO);
        glBufferData(GL_ARRAY_BUFFER, LineCount*sizeof(line_data), State->Lines, GL_STATIC_DRAW);

        State->LineCount = LineCount;
        State->SelectedCodepoint = Codepoint; 
    }
    EndTimingFunc();
}

internal void
TransitionCamera(camera *Camera, v2 NewPosition, f32 NewZoom, f32 Time)
{
    f32 TravelTime = .1f;
    Camera->Startpoint = Camera->Pos;
    Camera->Endpoint = NewPosition;
    Camera->MovementTime = TravelTime;
    Camera->MovementStartTime = Time;
    Camera->ZoomOrigin = Camera->Zoom;
    Camera->ZoomTarget = NewZoom;

    Camera->MovesTowardsEndpoint = true;
}

internal void
MoveCameraToWord(kmap_state *State, u32 WordIndex, f32 Time)
{
    rect WordBoundingBox = GetWordBoundingBox(State, WordIndex);
    TransitionCamera(&State->Camera, RectangleGetCenter(WordBoundingBox), State->Camera.Zoom, Time);
}

typedef struct
{
    u32 Count;
    u32 *Indices;
} visible_word_indices;

// NOTE: this is how the chunking system works:
//
// when we initially place the words, they are organized inside our array in a semi-sorted manner:
// for every MaxWordsInChunk words, their x and y position are never outside of that chunk's x,y * ChunkDim:
// __________________________________________________________
// |        word2     | word4     word6 |     word8 word9   | ChunkDim
// | word1    word3   |          word5  |    word7          |
// __________________________________________________________
// | ChunkDim         | ChunkDim        | ChunkDim          |
//
// Because of that, we can later (here) fiter out only the words that could
// possibly be visible (eiter in the camera's chunk, or in one of the neighbouring chunks),
// and only these words are ever considered for testing for visibility
//
// Also (for now) since all chunks except the very last one are always full, we don't have to have any kind of
// variable step in the following function, all of the offsets are fixed,
// and we don't actually have to store any kind of chunk structure.
internal visible_word_indices
GetVisibleWords(kmap_state *State)
{
    StartTimingFunc();
    visible_word_indices Result = 
    {
        .Indices = StartDynamicArray(&State->FrameArena, u32),
    };
    reference_layer *Layer = State->ReferenceHeader->Layers + State->MainLayerIndex;
    u32 LayerChunkCount = (Layer->ReferenceCount / WordsPerChunk) + 1;
    u32 MaxChunkCount = (State->WordCount / WordsPerChunk);
    iv2 CameraChunkPos = GetChunkPosFromWorldPos(State->Camera.Pos);

    for(i32 ChunkY = CameraChunkPos.y - 1;
        ChunkY <= CameraChunkPos.y + 1;
        ++ChunkY)
    {
        for(i32 ChunkX = CameraChunkPos.x - 1;
            ChunkX <= CameraChunkPos.x + 1;
            ++ChunkX)
        {
            u32 ChunkIndex = GetChunkIndex(MaxChunkCount, ChunkX, ChunkY);
            if(ChunkIndex < LayerChunkCount)
            {
                word_reference *References = State->ReferenceData + (State->MainLayerIndex * State->WordCount) + (WordsPerChunk * ChunkIndex);
                u32 ChunkReferenceCount =
                    (ChunkIndex + 1) == LayerChunkCount ?
                    Layer->ReferenceCount % WordsPerChunk :
                    WordsPerChunk;
                for(u32 ReferenceIndex = 0; ReferenceIndex < ChunkReferenceCount; ++ReferenceIndex)
                {
                    PushElement(&State->FrameArena, References[ReferenceIndex].WordIndex);
                }
            }
        }
    }

    Result.Count = EndDynamicArray(&State->FrameArena);
    EndTimingFunc();

    return Result;
}

internal void
PushBackground(text_render_queue *RenderQueue, rect BoundingBox, v4 Color)
{
    Assert((RenderQueue->BackgroundCount + 1) < RenderQueue->MaxBackgroundCount);
    text_background Background =
    {
        .Rect = BoundingBox,
        .Color = Color,
        .Depth = (f32)RenderQueue->BackgroundCount / DepthRange
    };
    RenderQueue->Backgrounds[RenderQueue->BackgroundCount++] = Background;
}

// TODO: we are still not doing fonts correctly (try smaller fonts to see that better)
internal rect
PushMulticoloredLine(kmap_state *State, text_render_queue *RenderQueue, v2 BottomLeftInPixelSpace, f32 FontScale, u32 CodepointCount, c32 *Codepoints, v4 *Colors)
{
    StartTimingFunc();
    Assert((RenderQueue->CharacterCount + CodepointCount) < RenderQueue->MaxCharacterCount);

    i32 Baseline = BottomLeftInPixelSpace.y;
    i32 Left = BottomLeftInPixelSpace.x;
    rect BoundingBox = 
    {
        .BottomLeft = V2(Left, Baseline),
        .TopRight = V2(Left, Baseline)
    };

    int GlyphIndex = 0,
        NextGlyphIndex = stbtt_FindGlyphIndex(&State->Font, Codepoints[0]);
    for(u32 CodepointIndex = 0; CodepointIndex < CodepointCount; ++CodepointIndex)
    {
        GlyphIndex = NextGlyphIndex;
        c32 Codepoint = Codepoints[CodepointIndex];
        glyph Glyph = GetOrMakeCodepointGlyph(State, Codepoint, FontScale);

        if(Codepoint != ' ')
        {
            v2 ScreenBottomLeft = V2(Left + Glyph.X0, Baseline - Glyph.Y1);
            v2 ScreenTopRight = V2(Left + Glyph.X1, Baseline - Glyph.Y0);
            //DebugDrawPoint(ScreenBottomLeft, RED);
            //DebugDrawPoint(ScreenTopRight, GREEN);
            //DebugDrawPoint(V2(ScreenBottomLeft.x, ScreenTopRight.y), RED);
            //DebugDrawPoint(V2(ScreenTopRight.x, ScreenBottomLeft.y), GREEN);

            BoundingBox.BottomLeft.y = Minimum(BoundingBox.BottomLeft.y, ScreenBottomLeft.y);
            BoundingBox.TopRight.y = Maximum(BoundingBox.TopRight.y, ScreenTopRight.y);
            v2 GlyphDim = V2(Glyph.X1 - Glyph.X0, Glyph.Y1 - Glyph.Y0);
            v2 TextureBottomLeft = V2TimesScalar(Glyph.AtlasTopLeft, 1.f / TASide);
            v2 TextureTopRight = V2TimesScalar(V2Add(Glyph.AtlasTopLeft, GlyphDim), 1.f / TASide);

            ui_text_display_data CharacterDisplayData =
            {
                .ScreenBottomLeft = ScreenBottomLeft,
                .ScreenTopRight = ScreenTopRight,
                .TextureTopLeft = V2(TextureBottomLeft.x, TextureTopRight.y),
                .TextureBottomRight = V2(TextureTopRight.x, TextureBottomLeft.y),
                .Color = Colors[CodepointIndex],
                .Depth = (f32)RenderQueue->BackgroundCount / DepthRange,
            };
            Assert(CharacterDisplayData.Depth >= 0.f);

            RenderQueue->Characters[RenderQueue->CharacterCount++] = CharacterDisplayData;
        }

        Left += FontScale * Glyph.Advance;

        if(CodepointIndex < (CodepointCount - 1))
        {
            NextGlyphIndex = stbtt_FindGlyphIndex(&State->Font, Codepoints[CodepointIndex + 1]);
            i32 Kerning = stbtt_GetGlyphKernAdvance(&State->Font, GlyphIndex, NextGlyphIndex);
            Left += FontScale * Kerning;
        }
    }
    BoundingBox.TopRight.x = Left;
    EndTimingFunc();
    return BoundingBox;
}

internal rect
PushSingleColoredLine(kmap_state *State, text_render_queue *RenderQueue, v2 BottomLeftInPixelSpace, f32 Scale, u32 CodepointCount, c32 *Codepoints, v4 Color)
{
    v4 Colors[CodepointCount];
    for(u32 ColorIndex = 0; ColorIndex < CodepointCount; ++ColorIndex)
    {
        Colors[ColorIndex] = Color;
    }
    rect Result = PushMulticoloredLine(State, RenderQueue, BottomLeftInPixelSpace, Scale, CodepointCount, Codepoints, Colors);
    return Result;
}

// object oriented codebase™
typedef struct
{
    kmap_state *State;
    text_render_queue *RenderQueue;

    v2 FirstLineBottomLeft;
    v2 Position;
    f32 LineHeight;
    f32 TextScale;
    u32 MaxCharactersPerLine;
    u32 MaxLines;
    u32 CurrentLineLength;
    u32 CurrentLineCount;

    rect BoundingBox;
} text_printer;

internal text_printer
TextPrinter(kmap_state *State, text_render_queue *RenderQueue, v2 FirstLineBottomLeft, f32 LineHeight, f32 TextScale, u32 MaxCharactersPerLine, u32 MaxLines)
{
    text_printer Result =
    {
        .State = State,
        .RenderQueue = RenderQueue,
        .Position = FirstLineBottomLeft,
        .FirstLineBottomLeft = FirstLineBottomLeft,
        .LineHeight = LineHeight,
        .TextScale = TextScale,
        .MaxCharactersPerLine = MaxCharactersPerLine,
        .MaxLines = MaxLines,
        .CurrentLineLength = 0,
        .CurrentLineCount = 0,
        .BoundingBox = 
        {
            .BottomLeft = FirstLineBottomLeft,
            .TopRight = FirstLineBottomLeft
        }
    };
    return Result;
}

internal void
SetPrinterPos(text_printer *Printer, v2 FirstLineBottomLeft)
{
    Printer->FirstLineBottomLeft = FirstLineBottomLeft;
    Printer->Position = FirstLineBottomLeft;
    Printer->CurrentLineCount = 0;
    Printer->CurrentLineLength = 0;
}

internal void
PrintNewline(text_printer *Printer)
{
    if(++Printer->CurrentLineCount > Printer->MaxLines)
    {
        SetPrinterPos(Printer, V2(Printer->BoundingBox.TopRight.x + Printer->State->Theme.DictionaryEntryPadding, Printer->FirstLineBottomLeft.y));
    }
    else
    {
        Printer->Position.y -= Printer->LineHeight;
        Printer->Position.x = Printer->FirstLineBottomLeft.x;
        Printer->CurrentLineLength = 0;
    }
}

internal rect
PrintCodepoints(text_printer *Printer, u32 CodepointCount, c32 *Codepoints, v4 Color)
{
    rect ThisCallBoundingBox = 
    {
        V2(99999999.f, 99999999.f),
        V2(-99999999.f, -99999999.f),
    };
    u32 TextIndex = 0;
    u32 LineOffset = 0;
    while(LineOffset < CodepointCount)
    {
        u32 LastBreakableCharacterIndex = -1;
        for(;(TextIndex < CodepointCount) && (Printer->CurrentLineLength <= Printer->MaxCharactersPerLine);
            ++Printer->CurrentLineLength, ++TextIndex)
        {
            c32 Character = Codepoints[TextIndex];

            if((Character == ' ') || (Character == '-'))
            {
                LastBreakableCharacterIndex = TextIndex;
            }
        }

        b32 FilledLine = Printer->CurrentLineLength > Printer->MaxCharactersPerLine;

        u32 CurrentCharacterCount = TextIndex - LineOffset;
        u32 CharactersToDraw = FilledLine ? Minimum(LastBreakableCharacterIndex - LineOffset, CurrentCharacterCount) : CurrentCharacterCount;
        rect LineBoundingBox = PushSingleColoredLine(Printer->State, Printer->RenderQueue, Printer->Position, Printer->TextScale, CharactersToDraw, Codepoints + LineOffset, Color);

        ThisCallBoundingBox.BottomLeft.x = Minimum(ThisCallBoundingBox.BottomLeft.x, LineBoundingBox.BottomLeft.x);
        ThisCallBoundingBox.BottomLeft.y = Minimum(ThisCallBoundingBox.BottomLeft.y, LineBoundingBox.BottomLeft.y);
        ThisCallBoundingBox.TopRight.x = Maximum(ThisCallBoundingBox.TopRight.x, LineBoundingBox.TopRight.x);
        ThisCallBoundingBox.TopRight.y = Maximum(ThisCallBoundingBox.TopRight.y, LineBoundingBox.TopRight.y);

        Printer->Position.x = LineBoundingBox.TopRight.x;

        LineOffset += CharactersToDraw;
        if(FilledLine)
        {
            PrintNewline(Printer);
        }
    }

    Printer->BoundingBox.BottomLeft.x = Minimum(Printer->BoundingBox.BottomLeft.x, ThisCallBoundingBox.BottomLeft.x);
    Printer->BoundingBox.BottomLeft.y = Minimum(Printer->BoundingBox.BottomLeft.y, ThisCallBoundingBox.BottomLeft.y);
    Printer->BoundingBox.TopRight.x = Maximum(Printer->BoundingBox.TopRight.x, ThisCallBoundingBox.TopRight.x);
    Printer->BoundingBox.TopRight.y = Maximum(Printer->BoundingBox.TopRight.y, ThisCallBoundingBox.TopRight.y);

    return ThisCallBoundingBox;
}

internal rect
PrintText(text_printer *Printer, char *Text, v4 Color)
{
    codepoints Codepoints = ConvertToCodepoints(Text);
    return PrintCodepoints(Printer, Codepoints.Count, Codepoints.Data, Color);
}

internal size_t
U32ToString(u32 Value, char *Result)
{
    size_t Length = 0;
    b32 ShouldWrite = false;
    static u32 PowersOf10[] =
    {
        1000000000,
        100000000,
        10000000,
        1000000,
        100000,
        10000,
        1000,
        100,
        10,
        1
    };
    for(u32 Po10Index = 0; Po10Index < ArrayCount(PowersOf10); ++Po10Index)
    {
        char Digit = (char)(Value / PowersOf10[Po10Index]);
        ShouldWrite = ShouldWrite || Digit;

        Value -= Digit * PowersOf10[Po10Index];
        if(ShouldWrite)
        {
            Result[Length++] = Digit + '0';
        }
    }
    return Length;
}

internal codepoints
U32ToCodepoints(u32 Value)
{
    codepoints Result = {0};
    b32 ShouldWrite = false;
    static u32 PowersOf10[] =
    {
        1000000000,
        100000000,
        10000000,
        1000000,
        100000,
        10000,
        1000,
        100,
        10,
        1
    };
    for(u32 Po10Index = 0; Po10Index < ArrayCount(PowersOf10); ++Po10Index)
    {
        u32 Digit = Value / PowersOf10[Po10Index];
        ShouldWrite = ShouldWrite || Digit;

        Value -= Digit * PowersOf10[Po10Index];
        if(ShouldWrite)
        {
            Result.Data[Result.Count++] = (c32)Digit + '0';
        }
    }
    return Result;
}

internal rect
DrawWordDictionaryInfo(kmap_state *State, text_render_queue *RenderQueue, f32 LineHeight, f32 KanjiUiHeight, u32 WordIndex, rect WordBoundingBox)
{
    StartTimingFunc();
    word *Word = State->Words + WordIndex;
    v4 *Colors = State->Theme.Colors;
    // NOTE: we draw the menu at (0,0) because in order to know where to place it
    // we need to know its dimensions, and the easiest way to get that is to draw it
    // and then just reposition if it gets outside the screen

    u32 LastCharacterIndexBeforeDrawing = RenderQueue->CharacterCount;

    text_printer Printer = TextPrinter(State, RenderQueue, V2(0, 0), LineHeight, State->UiTextScale, 40, 15);
    PrintText(&Printer, "Readings:", Colors[CT_Highlight]);
    PrintNewline(&Printer);

    char *NumberDelimiter = ". ";

    char CountDigits[8] = {0};
    char *Reading = Word->Readings;
    for(u32 ReadingIndex = 0; ReadingIndex < Word->ReadingCount; ++ReadingIndex)
    {
        if(Word->ReadingCount > 1)
        {
            U32ToString(ReadingIndex + 1, CountDigits);
            PrintText(&Printer, CountDigits, Colors[CT_Text]);
            PrintText(&Printer, NumberDelimiter, Colors[CT_Text]);
        }
        PrintText(&Printer, Reading, Colors[CT_Text]);
        while(*Reading)
        {
            ++Reading;
        }
        ++Reading;
        PrintNewline(&Printer);
    }

    PrintText(&Printer, "Meanings:", Colors[CT_Highlight]);
    PrintNewline(&Printer);

    char *Meaning = Word->Meanings;
    for(u32 MeaningIndex = 0; MeaningIndex < Word->MeaningCount; ++MeaningIndex)
    {
        if(Word->MeaningCount > 1)
        {
            U32ToString(MeaningIndex + 1, CountDigits);
            PrintText(&Printer, CountDigits, Colors[CT_Text]);
            PrintText(&Printer, NumberDelimiter, Colors[CT_Text]);
        }
        PrintText(&Printer, Meaning, Colors[CT_Text]);
        while(*Meaning)
        {
            ++Meaning;
        }
        ++Meaning;
        PrintNewline(&Printer);
    }

    // NOTE: we want to print the type only once, and print all the corresponding flags for it.
    for(u32 FlagTypeIndex = 0; FlagTypeIndex < ArrayCount(GlobalFlagTypes); ++FlagTypeIndex)
    {
        word_flag_type *FlagType = GlobalFlagTypes + FlagTypeIndex;
        b32 PrintedFlagType = false;
        for(u32 FlagIndex = 0; FlagIndex < Word->FlagCount; ++FlagIndex)
        {
            u8 Flag = Word->Flags[FlagIndex];
            if((Flag >= FlagType->MinimumValue) && (Flag <= FlagType->MaximumValue))
            {
                if(!PrintedFlagType)
                {
                    PrintedFlagType = true;
                    PrintText(&Printer, FlagType->Description, Colors[CT_Highlight]);
                    PrintNewline(&Printer);
                }

                c32 MiddleDotAndSpace[] = {0x2022, ' '};
                PrintCodepoints(&Printer, 2, MiddleDotAndSpace, Colors[CT_Text]);
                PrintText(&Printer, GlobalWordFlagNames[Flag], Colors[CT_Text]);
                PrintNewline(&Printer);
            }
        }
    }

    // NOTE: we want to position the box in a way
    // that it doesn't cover neither the word it's supposed to provide the information on,
    // nor the kanji ui.
    //
    // we have 5 cases:
    // --------------------
    // |   ^              |
    // |  b|              |
    // |<-==------------->|
    // |d  |            c |
    // |  av              |
    // |------------------|
    // |                  |
    // --------------------
    //
    // a) the word description fits underneath the word, y = bottom, x = left
    // b) it fits above, y = top, x = left
    //
    // otherwise, the word doesn't fit above OR below, in which case we snap its y to kanji ui height
    //
    // c) word description fits to the right, x = right
    // d) put the word description to the left, x = left - description.x

    rect InfoBoundingBox = Printer.BoundingBox;
    v2 InfoDim = RectangleGetDim(InfoBoundingBox);
    v2 InfoBoxMoveAmount;

#if 0
    rect WordBoundingBox = GetWordBoundingBox(State, WordIndex);
    v2 WordBottomLeft = WorldToPixelSpace(WordBoundingBox.BottomLeft, State->Camera);
    v2 WordTopRight = WorldToPixelSpace(WordBoundingBox.TopRight, State->Camera);
#else
    v2 WordBottomLeft = WordBoundingBox.BottomLeft;
    v2 WordTopRight = WordBoundingBox.TopRight;
#endif
    WordBottomLeft.y -= LineHeight;

    f32 DistanceToBottom = WordBottomLeft.y - KanjiUiHeight;

    f32 BorderDim = State->Theme.UiBorderWidth + State->Theme.DictionaryEntryPadding;
    f32 BorderWidth = State->Theme.UiBorderWidth;

    // case a
    if(DistanceToBottom > InfoDim.y)
    {
        InfoBoxMoveAmount.y = Minimum(WordBottomLeft.y, State->Camera.Dim.y);
        InfoBoxMoveAmount.y -= BorderDim;
        InfoBoxMoveAmount.x = Clamp(WordBottomLeft.x, BorderDim, State->Camera.Dim.x - InfoDim.x - BorderDim);
    }
    else
    {
        f32 DistanceToTop = State->Camera.Dim.y - WordTopRight.y;
        // b
        if(DistanceToTop > InfoDim.y)
        {
            InfoBoxMoveAmount.y = Maximum(WordTopRight.y, KanjiUiHeight);
            InfoBoxMoveAmount.y += InfoDim.y;// + BorderDim;
            InfoBoxMoveAmount.x = Clamp(WordBottomLeft.x, BorderDim, State->Camera.Dim.x - InfoDim.x - BorderDim);
        }
        else
        {
            InfoBoxMoveAmount.y = KanjiUiHeight + InfoDim.y;
            f32 DistanceToRight = State->Camera.Dim.y - WordTopRight.x;
            // c
            if(DistanceToRight > InfoDim.x)
            {
                InfoBoxMoveAmount.x = WordTopRight.x + BorderDim;
            }
            else // d
            {
                InfoBoxMoveAmount.x = WordBottomLeft.x - InfoDim.x - BorderDim;
            }
        }
    }

    // remap everything we have drawn so far
    for(u32 CharacterIndex = LastCharacterIndexBeforeDrawing;
        CharacterIndex < RenderQueue->CharacterCount;
        ++CharacterIndex)
    {
        ui_text_display_data *Character = RenderQueue->Characters + CharacterIndex;
        Character->ScreenBottomLeft.x += InfoBoxMoveAmount.x;
        Character->ScreenBottomLeft.y += InfoBoxMoveAmount.y;
        Character->ScreenTopRight.x += InfoBoxMoveAmount.x;
        Character->ScreenTopRight.y += InfoBoxMoveAmount.y;
    }

    InfoBoundingBox.BottomLeft = V2Add(InfoBoundingBox.BottomLeft, InfoBoxMoveAmount);
    InfoBoundingBox.TopRight = V2Add(InfoBoundingBox.TopRight, InfoBoxMoveAmount);

    PushBackground(RenderQueue, InfoBoundingBox, State->Theme.Colors[CT_Text]);
    EndTimingFunc();
    return InfoBoundingBox;
}

typedef enum
{
    SF_None,
    SF_Readings,
    SF_Meanings,
} search_field;

typedef struct
{
    u32 MatchCount;
    u32 ClosestMatchIndex;
    u32 *Indices;
} search_result;

// this is bad architecture, and has already led to bugs !!!
internal search_result 
SearchInWords(size_t QueryLength, char *Query, u32 WordCount, word *Words, search_field SearchField, memory_arena *Arena)
{
    Assert(QueryLength);
    size_t FieldOffset = 0;
    size_t FieldCountOffset = 0;
    switch(SearchField)
    {
        case SF_Readings:
        {
            FieldOffset = offsetof(word, Readings);
            FieldCountOffset = offsetof(word, ReadingCount);
        } break;
        case SF_Meanings:
        {
            FieldOffset = offsetof(word, Meanings);
            FieldCountOffset = offsetof(word, MeaningCount);
        } break;
        InvalidDefaultCase;
    }

    search_result Result = 
    {
        .Indices = StartDynamicArray(Arena, u32)
    };

    for(u32 WordIndex = 0; WordIndex < WordCount; ++WordIndex)
    {
        word *Word = Words + WordIndex;
        char *Field = *(char **)((char *)Word + FieldOffset);
        u8 FieldCount = *(u8 *)((char *)Word + FieldCountOffset);
        for(u32 FieldIndex = 0; FieldIndex < FieldCount; ++FieldIndex)
        {
            size_t QueryPos = 0;
            size_t ThisFieldLength = 0;
            char FieldChar;
            do
            {
                FieldChar = *Field++;
                if(QueryPos == (QueryLength - 1))
                {
                    // found a match
                    PushElement(Arena, WordIndex);
                    if(ThisFieldLength == QueryLength)
                    {
                        Result.ClosestMatchIndex = Arena->ArrayCount - 1;
                    }
                    goto NextWord;
                }
                else 
                {
                    char QueryChar = Query[QueryPos++];
                    if(QueryChar != FieldChar)
                    {
                        QueryPos = 0;
                    }
                }
                ++ThisFieldLength;
            }  while(FieldChar);
            ++Field;
        }
NextWord:
    }

    Result.MatchCount = EndDynamicArray(Arena);
    return Result;
}

internal void
SelectWord(kmap_state *State, u32 WordIndex, f32 Time, memory_arena *Arena)
{
    word *Word = State->Words + WordIndex;
    MoveCameraToWord(State, WordIndex, Time);
    for(char *Writing = Word->Writing;
        *Writing;)
    {
        c32 Character;
        Writing += ConvertSingleUtf8(Writing, &Character);
        if(IsKanji(Character))
        {
            SelectKanjiAndDrawLines(State, WordIndex, Character);
            break;
        }
    }
}

internal search_result
SearchAndSelectClosestMatch(kmap_state *State, u32 QueryLength, char *Query, search_field Field, memory_arena *Arena, f32 Time)
{
    //word_reference_layer *MainLayer = State->ReferenceLayers + State->MainLayerIndex;
    search_result Matches = SearchInWords(QueryLength, Query, State->WordCount, State->Words, Field, Arena);
    if(Matches.MatchCount)
    {
        u32 ClosestMatchIndex = Matches.Indices[Matches.ClosestMatchIndex];
        SelectWord(State, ClosestMatchIndex, Time, Arena);
    }
    return Matches;
}

typedef struct
{
    b32 IsValid;
    codepoints Value;
} conversion_result;

internal conversion_result
ConvertToHiragana(codepoints Codepoints)
{
    conversion_result Result =
    {
        .IsValid = true
    };
#define IsVowel(Codepoint) (((Codepoint) == 'a') || ((Codepoint) == 'i') || ((Codepoint) == 'u') || ((Codepoint) == 'e') || ((Codepoint) == 'o'))
#define AUO(Codepoint) (((Codepoint) == 'a') || ((Codepoint) == 'u') || ((Codepoint) == 'o'))

    static c32 ARow[] = { ['a'] = L'あ', ['i'] = L'い', ['u'] = L'う', ['e'] = L'え', ['o'] = L'お' };

    static c32 TwoLetterSyllables[]['v'] = 
    {
        ['k'] = { ['a'] = L'か', ['i'] = L'き', ['u'] = L'く', ['e'] = L'け', ['o'] = L'こ' },
        ['g'] = { ['a'] = L'が', ['i'] = L'ぎ', ['u'] = L'ぐ', ['e'] = L'げ', ['o'] = L'ご' },
        ['h'] = { ['a'] = L'は', ['i'] = L'ひ', ['u'] = L'ふ', ['e'] = L'へ', ['o'] = L'ほ' },
        ['b'] = { ['a'] = L'ば', ['i'] = L'び', ['u'] = L'ぶ', ['e'] = L'べ', ['o'] = L'ぼ' },
        ['p'] = { ['a'] = L'ぱ', ['i'] = L'ぴ', ['u'] = L'ぷ', ['e'] = L'ぺ', ['o'] = L'ぽ' },
        ['t'] = { ['a'] = L'た', ['i'] = L'ち', ['u'] = L'つ', ['e'] = L'て', ['o'] = L'と' },
        ['d'] = { ['a'] = L'だ', ['i'] = L'ぢ', ['u'] = L'づ', ['e'] = L'で', ['o'] = L'ど' },
        ['n'] = { ['a'] = L'な', ['i'] = L'に', ['u'] = L'ぬ', ['e'] = L'ね', ['o'] = L'の' },
        ['m'] = { ['a'] = L'ま', ['i'] = L'み', ['u'] = L'む', ['e'] = L'め', ['o'] = L'も' },
        ['s'] = { ['a'] = L'さ', ['i'] = L'し', ['u'] = L'す', ['e'] = L'せ', ['o'] = L'そ' },
        ['z'] = { ['a'] = L'ざ', ['i'] = L'じ', ['u'] = L'ず', ['e'] = L'ぜ', ['o'] = L'ぞ' },
        ['r'] = { ['a'] = L'ら', ['i'] = L'り', ['u'] = L'る', ['e'] = L'れ', ['o'] = L'ろ' }
    };

    static c32 YRow[] = { ['a'] = L'や', ['u'] = L'ゆ', ['o'] = L'よ' };
    static c32 SmallYRow[] = { ['a'] = L'ゃ', ['u'] = L'ゅ', ['o'] = L'ょ'};

    for(u32 CodepointIndex = 0; CodepointIndex < Codepoints.Count; ++CodepointIndex)
    {
        c32 Codepoint = Codepoints.Data[CodepointIndex];
        if(Codepoint >= 'A' && Codepoint <= 'Z')
        {
            Codepoints.Data[CodepointIndex] += 'a' - 'A';
        }
    }

    for(u32 CodepointIndex = 0; CodepointIndex < Codepoints.Count; ++CodepointIndex)
    {
        c32 Codepoint = Codepoints.Data[CodepointIndex];
        if((Codepoint >= 'A') && (Codepoint <= 'Z'))
        {
            Codepoint += 'a' - 'Z';
        }
#define InsertChar(Character) Result.Value.Data[Result.Value.Count++] = (Character)

#define GetCodepoint(CodepointName) \
                if((++CodepointIndex) >= Codepoints.Count) \
                { \
                    goto Invalid; \
                } \
                c32 CodepointName = Codepoints.Data[CodepointIndex];

#define GetRepeated(CodepointName) \
        c32 CodepointName; \
        do \
        { \
            if((++CodepointIndex) > Codepoints.Count) \
            { \
                goto Invalid; \
            } \
            CodepointName = Codepoints.Data[CodepointIndex]; \
            if(CodepointName == Codepoint) \
            { \
                InsertChar(L'っ'); \
            } \
        } while(CodepointName == Codepoint);

        switch(Codepoint)
        {
            case 'a':
            case 'i':
            case 'u':
            case 'e':
            case 'o':
            {
                InsertChar(ARow[Codepoint]);
            } break;
            case 's': 
            case 'k':
            case 'g':
            case 'h':
            case 'b':
            case 'p':
            case 't':
            case 'd':
            case 'm':
            case 'z':
            case 'r':
            {
                GetRepeated(SecondCodepoint);

                if(IsVowel(SecondCodepoint))
                {
                    InsertChar(TwoLetterSyllables[Codepoint][SecondCodepoint]);
                }
                else if(SecondCodepoint == 'y' || ((Codepoint == 's') && (SecondCodepoint == 'h')))
                {
                    GetCodepoint(ThirdCodepoint);
                    if(AUO(ThirdCodepoint))
                    {
                        InsertChar(TwoLetterSyllables[Codepoint]['i']);
                        InsertChar(SmallYRow[ThirdCodepoint]);
                    }
                    else
                    {
                        goto Invalid;
                    }
                }
                else if(Codepoint == 't' && SecondCodepoint == 's')
                {
                    GetCodepoint(ThirdCodepoint);
                    if(ThirdCodepoint == 'u')
                    {
                        InsertChar(L'つ');
                    }
                    else
                    {
                        goto Invalid;
                    }
                }
                else
                {
                    goto Invalid;
                }
            } break;
            case 'f':
            {
                GetRepeated(SecondCodepoint);
                if(SecondCodepoint == 'u')
                {
                    InsertChar(L'ふ');
                }
                else
                {
                    goto Invalid;
                }
            } break;
            case 'w':
            {
                GetRepeated(SecondCodepoint);
                if(SecondCodepoint == 'a')
                {
                    InsertChar(L'わ');
                }
                else if(SecondCodepoint == 'o')
                {
                    InsertChar(L'を');
                }
                else
                {
                    goto Invalid;
                }
            } break;
            case 'y':
            {
                GetRepeated(SecondCodepoint);

                if(AUO(SecondCodepoint))
                {
                    InsertChar(YRow[SecondCodepoint]);
                }
                else
                {
                    goto Invalid;
                }
            } break;
            case 'c':
            {
                GetRepeated(SecondCodepoint);
                if(SecondCodepoint == 'h') 
                {
                    GetCodepoint(ThirdCodepoint);
                    if(AUO(ThirdCodepoint))
                    {
                        InsertChar(L'ち');
                        InsertChar(SmallYRow[ThirdCodepoint]);
                    }
                    else if(ThirdCodepoint == 'i')
                    {
                        InsertChar(L'ち');
                    }
                    else
                    {
                        goto Invalid;
                    }
                }
                else
                {
                    goto Invalid;
                }
            } break;
            case 'j':
            {
                GetRepeated(SecondCodepoint);
                if(AUO(SecondCodepoint))
                {
                    InsertChar(L'じ');
                    InsertChar(SmallYRow[SecondCodepoint]);
                }
                else if(SecondCodepoint == 'i')
                {
                    InsertChar(L'じ');
                }
                else
                {
                    goto Invalid;
                }
            } break;
            case 'n':
            {
                if((++CodepointIndex) < Codepoints.Count)
                {
                    c32 SecondCodepoint = Codepoints.Data[CodepointIndex];

                    if(IsVowel(SecondCodepoint))
                    {
                        Result.Value.Data[Result.Value.Count++] = TwoLetterSyllables[Codepoint][SecondCodepoint];
                    }
                    else if(SecondCodepoint == 'y')
                    {
                        GetCodepoint(ThirdCodepoint);
                        if(AUO(ThirdCodepoint))
                        {
                            InsertChar(L'に');
                            InsertChar(SmallYRow[ThirdCodepoint]);
                        }
                    }
                    else if(SecondCodepoint == 'n') // ex. れんあい -> rennnai
                    {
                        InsertChar(L'ん');
                    }
                    else
                    {
                        InsertChar(L'ん');
                        --CodepointIndex;
                    }
                }
                else
                {
                    InsertChar(L'ん');
                }
            } break;
            default:
            {
Invalid:
                Result.IsValid = false;
                return Result;
            } break;
        }
    }
    return Result;
}

internal v2
GetCodepointsDim(stbtt_fontinfo *Font, f32 FontPadding, f32 FontScale, codepoints Writing)
{
    v2 Result = {0};

    i32 Baseline = 0;
    i32 Left = 0;
    int GlyphIndex = 0,
        NextGlyphIndex = stbtt_FindGlyphIndex(Font, Writing.Data[0]);
    for(u32 CodepointIndex = 0; CodepointIndex < Writing.Count; ++CodepointIndex)
    {
        GlyphIndex = NextGlyphIndex;
        NextGlyphIndex = stbtt_FindGlyphIndex(Font, Writing.Data[CodepointIndex + 1]);

        int X0, X1, Y0, Y1;
        stbtt_GetGlyphBitmapBox(Font, GlyphIndex, FontScale, FontScale, &X0, &Y0, &X1, &Y1);

        Result.y = Maximum(Result.y, Y1 - Y0);

        i32 Kerning = stbtt_GetGlyphKernAdvance(Font, GlyphIndex, NextGlyphIndex);
        i32 Advance, Lsb;
        stbtt_GetGlyphHMetrics(Font, GlyphIndex, &Advance, &Lsb);

        Left += FontScale * (Kerning + Advance);
    }
    Result.x = Left;
    Result.x += FontPadding;
    Result.y += FontPadding;
    return Result;
}

// https://sites.google.com/site/murmurhash/
internal u32
MurmurHash2(const void *Key, int Len, u32 Seed)
{
	// 'm' and 'r' are mixing constants generated offline.
	// They're not really 'magic', they just happen to work well.

	u32 m = 0x5bd1e995;
	i32 r = 24;

	// Initialize the hash to a 'random' value

	u32 h = Seed ^ Len;

	// Mix 4 bytes at a time into the hash

	u8 *Data = (u8 *)Key;

	while(Len >= 4)
	{
		u32 k = *(u32 *)Data;

		k *= m; 
		k ^= k >> r; 
		k *= m; 
		
		h *= m; 
		h ^= k;

		Data += 4;
		Len -= 4;
	}
	
	// Handle the last few bytes of the input array

	switch(Len)
	{
        case 3: h ^= Data[2] << 16; // fallthrough
        case 2: h ^= Data[1] << 8; // fallthrough
        case 1: h ^= Data[0];
                h *= m;
	};

	// Do a few final mixes of the hash to ensure the last few
	// bytes are well-incorporated.

	h ^= h >> 13;
	h *= m;
	h ^= h >> 15;

	return h;
}

internal void
ZoomIn(camera *Camera, v2 LastFrameMousePos, f32 dTime, f64 TimeNow)
{
    f32 MaximumZoom = Camera->DefaultZoom * 3.f;
    f32 NewZoom = Camera->Zoom*1.25f;
    // clamping is very important!
    if(NewZoom < MaximumZoom)
    {
        v2 LastFrameMouseWorldPos = PixelToWorldSpace(LastFrameMousePos, *Camera);
        // TODO: a correct formula 
        v2 NewPos = V2Lerp(Camera->Pos, LastFrameMouseWorldPos, .05f);
        TransitionCamera(Camera, NewPos, NewZoom, TimeNow);
    }
}

internal void
ZoomOut(camera *Camera, f32 dTime, f64 TimeNow)
{
    f32 MinimumZoom = Camera->DefaultZoom * .5f;
    f32 NewZoom = Camera->Zoom/1.25f;
    NewZoom = Maximum(NewZoom, MinimumZoom);
    TransitionCamera(Camera, Camera->Pos, NewZoom, TimeNow);
}

internal void
GenerateCache(kmap_state *State, u32 FontNameHash, platform_memory *Memory)
{
    size_t CacheSize = sizeof(reference_cache_header) + sizeof(rect)*State->WordCount*ReferenceLayerCount;
    State->ReferenceHeader = PushStruct(&State->Arena, reference_cache_header);
    *State->ReferenceHeader = (reference_cache_header)
    {
        .Magic = REFERENCE_CACHE_MAGIC,
        .Version = REFERENCE_CACHE_VERSION,
        .WordCount = State->WordCount,
        .FontNameHash = FontNameHash,
    };
    State->ReferenceData = PushStaticArray(&State->Arena, word_reference, State->WordCount * ReferenceLayerCount);
    u64 InitialRngSeed = 17298136516911894399u;
    for(u32 LayerIndex = 0; LayerIndex < ReferenceLayerCount; ++LayerIndex)
    {
        reference_layer *Layer = State->ReferenceHeader->Layers + LayerIndex;
        Layer->CameraPos = V2(0.f, 0.f);
        Layer->Rng = InitialRngSeed + LayerIndex;
    }
    reference_layer *FirstLayer = State->ReferenceHeader->Layers;
    FirstLayer->ReferenceCount = State->WordCount;
    u32 ChunkCount = State->WordCount / WordsPerChunk;
    i32 ChunkTotalRows = (i32)Sqrt((f32)ChunkCount);
    // setup the main layer's positions
    // TODO: proper thing here  
    rect OtherWordRects[WordsPerChunk] = {0};
    for(u32 WordIndex = 0; WordIndex < State->WordCount; ++WordIndex)
    {
        word *Word = State->Words + WordIndex;
        word_reference *Reference = State->ReferenceData + WordIndex; 
        u32 ChunkIndex = WordIndex / WordsPerChunk;
        u32 WordChunkRelativeIndex = WordIndex % WordsPerChunk;
        v2 WordDim = GetCodepointsDim(&State->Font, State->Theme.DictionaryEntryPadding, State->LargestFontScale, ConvertToCodepoints(Word->Writing));
        rect BoundingBox = GetNewWordBoundingBox(&FirstLayer->Rng, ChunkTotalRows, ChunkIndex, WordDim, WordChunkRelativeIndex, OtherWordRects);
        Reference->BoundingBox = BoundingBox;
        Reference->WordIndex = WordIndex;
        OtherWordRects[WordChunkRelativeIndex] = Reference->BoundingBox;
    }

    Memset(State->ReferenceData + State->WordCount, 0, sizeof(word_reference)*State->WordCount*(ReferenceLayerCount - 1));
    Platform.WriteFile(Memory->CachePath, CacheSize, State->ReferenceHeader);
}

#if 0
internal codepoints
GetRadicalMeaning(c32 Radical)
{
    char *Result = 0;
    switch(Radical)
    {
        case 0x4E00: Result = "One"; break;
        case 0x4E28: Result = "Line"; break;
        case 0x4E36: Result = "Dot"; break;
        case 0x4E3F: Result = "Slash"; break;
        case 0x4E59: Result = "Second"; break;
        case 0x4E85: Result = "Hook"; break;
        case 0x4E8C: Result = "Two"; break;
        case 0x4EA0: Result = "Lid"; break;
        case 0x4EBA: Result = "Man"; break;
        case 0x513F: Result = "Legs"; break;
        case 0x5165: Result = "Enter"; break;
        case 0x516B: Result = "Eight"; break;
        case 0x5182: Result = "Down Box"; break;
        case 0x5196: Result = "Cover"; break;
        case 0x51AB: Result = "Ice"; break;
        case 0x51E0: Result = "Table"; break;
        case 0x51F5: Result = "Open Box"; break;
        case 0x5200: Result = "Knife"; break;
        case 0x529B: Result = "Power"; break;
        case 0x52F9: Result = "Wrap"; break;
        case 0x5315: Result = "Spoon"; break;
        case 0x531A: Result = "Right Open Box"; break;
        case 0x5338: Result = "Hiding Enclosure"; break;
        case 0x5341: Result = "Ten"; break;
        case 0x535C: Result = "Divination"; break;
        case 0x5369: Result = "Seal"; break;
        case 0x5382: Result = "Cliff"; break;
        case 0x53B6: Result = "Private"; break;
        case 0x53C8: Result = "Again"; break;
        case 0x53E3: Result = "Mouth"; break;
        case 0x56D7: Result = "Enclosure"; break;
        case 0x571F: Result = "Earth"; break;
        case 0x58EB: Result = "Scholar"; break;
        case 0x5902: Result = "Go"; break;
        case 0x590A: Result = "Go Slowly"; break;
        case 0x5915: Result = "Evening"; break;
        case 0x5927: Result = "Big"; break;
        case 0x5973: Result = "Woman"; break;
        case 0x5B50: Result = "Child"; break;
        case 0x5B80: Result = "Roof"; break;
        case 0x5BF8: Result = "Inch"; break;
        case 0x5C0F: Result = "Small"; break;
        case 0x5C22: Result = "Lame"; break;
        case 0x5C38: Result = "Corpse"; break;
        case 0x5C6E: Result = "Sprout"; break;
        case 0x5C71: Result = "Mountain"; break;
        case 0x5DDB: Result = "River"; break;
        case 0x5DE5: Result = "Work"; break;
        case 0x5DF1: Result = "Oneself"; break;
        case 0x5DFE: Result = "Turban"; break;
        case 0x5E72: Result = "Dry"; break;
        case 0x5E7A: Result = "Short Thread"; break;
        case 0x5E7F: Result = "Dotted Cliff"; break;
        case 0x5EF4: Result = "Long Stride"; break;
        case 0x5EFE: Result = "Two Hands"; break;
        case 0x5F0B: Result = "Shoot"; break;
        case 0x5F13: Result = "Bow"; break;
        case 0x5F50: Result = "Snout"; break;
        case 0x5F61: Result = "Bristle"; break;
        case 0x5F73: Result = "Step"; break;
        case 0x5FC3: Result = "Heart"; break;
        case 0x6208: Result = "Halberd"; break;
        case 0x6236: Result = "Door"; break;
        case 0x624B: Result = "Hand"; break;
        case 0x652F: Result = "Branch"; break;
        case 0x6534: Result = "Rap"; break;
        case 0x6587: Result = "Script"; break;
        case 0x6597: Result = "Dipper"; break;
        case 0x65A4: Result = "Axe"; break;
        case 0x65B9: Result = "Square"; break;
        case 0x65E0: Result = "Not"; break;
        case 0x65E5: Result = "Sun"; break;
        case 0x66F0: Result = "Say"; break;
        case 0x6708: Result = "Moon"; break;
        case 0x6728: Result = "Tree"; break;
        case 0x6B20: Result = "Lack"; break;
        case 0x6B62: Result = "Stop"; break;
        case 0x6B79: Result = "Death"; break;
        case 0x6BB3: Result = "Weapon"; break;
        case 0x6BCB: Result = "Do Not"; break;
        case 0x6BD4: Result = "Compare"; break;
        case 0x6BDB: Result = "Fur"; break;
        case 0x6C0F: Result = "Clan"; break;
        case 0x6C14: Result = "Steam"; break;
        case 0x6C34: Result = "Water"; break;
        case 0x706B: Result = "Fire"; break;
        case 0x722A: Result = "Claw"; break;
        case 0x7236: Result = "Father"; break;
        case 0x723B: Result = "Double X"; break;
        case 0x723F: Result = "Half Tree Trunk"; break;
        case 0x7247: Result = "Slice"; break;
        case 0x7259: Result = "Fang"; break;
        case 0x725B: Result = "Cow"; break;
        case 0x72AC: Result = "Dog"; break;
        case 0x7384: Result = "Profound"; break;
        case 0x7389: Result = "Jade"; break;
        case 0x74DC: Result = "Melon"; break;
        case 0x74E6: Result = "Tile"; break;
        case 0x7518: Result = "Sweet"; break;
        case 0x751F: Result = "Life"; break;
        case 0x7528: Result = "Use"; break;
        case 0x7530: Result = "Field"; break;
        case 0x758B: Result = "Bolt Of Cloth"; break;
        case 0x7592: Result = "Sickness"; break;
        case 0x7676: Result = "Dotted Tent"; break;
        case 0x767D: Result = "White"; break;
        case 0x76AE: Result = "Skin"; break;
        case 0x76BF: Result = "Dish"; break;
        case 0x76EE: Result = "Eye"; break;
        case 0x77DB: Result = "Spear"; break;
        case 0x77E2: Result = "Arrow"; break;
        case 0x77F3: Result = "Stone"; break;
        case 0x793A: Result = "Spirit"; break;
        case 0x79B8: Result = "Track"; break;
        case 0x79BE: Result = "Grain"; break;
        case 0x7A74: Result = "Cave"; break;
        case 0x7ACB: Result = "Stand"; break;
        case 0x7AF9: Result = "Bamboo"; break;
        case 0x7C73: Result = "Rice"; break;
        case 0x7CF8: Result = "Silk"; break;
        case 0x7F36: Result = "Jar"; break;
        case 0x7F51: Result = "Net"; break;
        case 0x7F8A: Result = "Sheep"; break;
        case 0x7FBD: Result = "Feather"; break;
        case 0x8001: Result = "Old"; break;
        case 0x800C: Result = "And"; break;
        case 0x8012: Result = "Plow"; break;
        case 0x8033: Result = "Ear"; break;
        case 0x807F: Result = "Brush"; break;
        case 0x8089: Result = "Meat"; break;
        case 0x81E3: Result = "Minister"; break;
        case 0x81EA: Result = "Self"; break;
        case 0x81F3: Result = "Arrive"; break;
        case 0x81FC: Result = "Mortar"; break;
        case 0x820C: Result = "Tongue"; break;
        case 0x821B: Result = "Oppose"; break;
        case 0x821F: Result = "Boat"; break;
        case 0x826E: Result = "Stopping"; break;
        case 0x8272: Result = "Color"; break;
        case 0x8278: Result = "Grass"; break;
        case 0x864D: Result = "Tiger"; break;
        case 0x866B: Result = "Insect"; break;
        case 0x8840: Result = "Blood"; break;
        case 0x884C: Result = "Walk Enclosure"; break;
        case 0x8863: Result = "Clothes"; break;
        case 0x897E: Result = "West"; break;
        case 0x898B: Result = "See"; break;
        case 0x89D2: Result = "Horn"; break;
        case 0x8A00: Result = "Speech"; break;
        case 0x8C37: Result = "Valley"; break;
        case 0x8C46: Result = "Bean"; break;
        case 0x8C55: Result = "Pig"; break;
        case 0x8C78: Result = "Badger"; break;
        case 0x8C9D: Result = "Shell"; break;
        case 0x8D64: Result = "Red"; break;
        case 0x8D70: Result = "Run"; break;
        case 0x8DB3: Result = "Foot"; break;
        case 0x8EAB: Result = "Body"; break;
        case 0x8ECA: Result = "Cart"; break;
        case 0x8F9B: Result = "Bitter"; break;
        case 0x8FB0: Result = "Morning"; break;
        case 0x8FB5: Result = "Walk"; break;
        case 0x9091: Result = "City"; break;
        case 0x9149: Result = "Wine"; break;
        case 0x91C6: Result = "Distinguish"; break;
        case 0x91CC: Result = "Village"; break;
        case 0x91D1: Result = "Gold"; break;
        case 0x9577: Result = "Long"; break;
        case 0x9580: Result = "Gate"; break;
        case 0x961C: Result = "Mound"; break;
        case 0x96B6: Result = "Slave"; break;
        case 0x96B9: Result = "Short Tailed Bird"; break;
        case 0x96E8: Result = "Rain"; break;
        case 0x9751: Result = "Blue"; break;
        case 0x975E: Result = "Wrong"; break;
        case 0x9762: Result = "Face"; break;
        case 0x9769: Result = "Leather"; break;
        case 0x97CB: Result = "Tanned Leather"; break;
        case 0x97ED: Result = "Leek"; break;
        case 0x97F3: Result = "Sound"; break;
        case 0x9801: Result = "Leaf"; break;
        case 0x98A8: Result = "Wind"; break;
        case 0x98DB: Result = "Fly"; break;
        case 0x98DF: Result = "Eat"; break;
        case 0x9996: Result = "Head"; break;
        case 0x9999: Result = "Fragrant"; break;
        case 0x99AC: Result = "Horse"; break;
        case 0x9AA8: Result = "Bone"; break;
        case 0x9AD8: Result = "Tall"; break;
        case 0x9ADF: Result = "Hair"; break;
        case 0x9B25: Result = "Fight"; break;
        case 0x9B2F: Result = "Sacrificial Wine"; break;
        case 0x9B32: Result = "Cauldron"; break;
        case 0x9B3C: Result = "Ghost"; break;
        case 0x9B5A: Result = "Fish"; break;
        case 0x9CE5: Result = "Bird"; break;
        case 0x9E75: Result = "Salt"; break;
        case 0x9E7F: Result = "Deer"; break;
        case 0x9EA5: Result = "Wheat"; break;
        case 0x9EBB: Result = "Hemp"; break;
        case 0x9EC3: Result = "Yellow"; break;
        case 0x9ECD: Result = "Millet"; break;
        case 0x9ED1: Result = "Black"; break;
        case 0x9EF9: Result = "Embroidery"; break;
        case 0x9EFD: Result = "Frog"; break;
        case 0x9F0E: Result = "Tripod"; break;
        case 0x9F13: Result = "Drum"; break;
        case 0x9F20: Result = "Rat"; break;
        case 0x9F3B: Result = "Nose"; break;
        case 0x9F4A: Result = "Even"; break;
        case 0x9F52: Result = "Tooth"; break;
        case 0x9F8D: Result = "Dragon"; break;
        case 0x9F9C: Result = "Turtle"; break;
        case 0x9FA0: Result = "Flute"; break;
    }
    return Result;
    //    default: {}
    //   return Result;

    //switch(Radical)
    //{
    //    case L'⼀': { Result = ConvertToCodepoints("one, horizontal stroke (いち)"); } break;
    //    case L'⼁': { Result = ConvertToCodepoints("vertical stroke (たてぼう)"); } break;
    //    case L'⼂': { Result = ConvertToCodepoints("dot (てん)"); } break;
    //    case L'⼃': { Result = ConvertToCodepoints("diagonal sweeping stroke (の)"); } break;
    //    case L'': { Result = ConvertToCodepoints("diagonal sweeping stroke (のかんむり)"); } break;
    //    case L'⼄': { Result = ConvertToCodepoints("the second  (おつ)"); } break;
    //    case L'⺃': { Result = ConvertToCodepoints("the second (おつ)"); } break;
    //    case L'⼅': { Result = ConvertToCodepoints("vertical stroke with a hook (はねぼう)"); } break;
    //    case L'⼆': { Result = ConvertToCodepoints("two (に)"); } break;
    //    case L'⼇': { Result = ConvertToCodepoints("lid, top (なべぶた)"); } break;
    //    case L'⼈': { Result = ConvertToCodepoints("person (ひと)"); } break;
    //    case L'⺅': { Result = ConvertToCodepoints("person  (にんべん)"); } break;
    //    //case L'𠆢': { Result = ConvertToCodepoints("person  (ひとやね)"); } break;
    //    case L'⼉': { Result = ConvertToCodepoints("human legs (ひとあし)"); } break;
    //    case L'⼊': { Result = ConvertToCodepoints("to enter (いる)"); } break;
    //    case L'⼋': { Result = ConvertToCodepoints("eight (はち)"); } break;
    //    case L'': { Result = ConvertToCodepoints("eight (はちがしら)"); } break;
    //    case L'⼌': { Result = ConvertToCodepoints("to enclose (けいがまえ)"); } break;
    //    case L'⼍': { Result = ConvertToCodepoints("cover, crown (わかんむり)"); } break;
    //    case L'⼎': { Result = ConvertToCodepoints("ice (にすい)"); } break;
    //    case L'⼏': { Result = ConvertToCodepoints("table (きにょう)"); } break;
    //    case L'⺇': { Result = ConvertToCodepoints("wind (かぜかんむり)"); } break;
    //    case L'⼐': { Result = ConvertToCodepoints("container, open box (かんにょう)"); } break;
    //    case L'⼑': { Result = ConvertToCodepoints("knife, sword (かたな)"); } break;
    //    case L'⺉': { Result = ConvertToCodepoints("knife, sword (りっとう)"); } break;
    //    case L'⼒': { Result = ConvertToCodepoints("power (ちから)"); } break;
    //    case L'⼓': { Result = ConvertToCodepoints("to wrap (つつみがまえ)"); } break;
    //    case L'⼔': { Result = ConvertToCodepoints("spoon (さじ)"); } break;
    //    case L'⼕': { Result = ConvertToCodepoints("box (はこがまえ)"); } break;
    //    case L'⼖': { Result = ConvertToCodepoints("to conceal, hide (かくしがまえ)"); } break;
    //    case L'⼗': { Result = ConvertToCodepoints("ten (じゅう)"); } break;
    //    case L'⼘': { Result = ConvertToCodepoints("oracle (ぼく)"); } break;
    //    case L'⼙': { Result = ConvertToCodepoints("stamp, seal (ふしづくり)"); } break;
    //    case L'⼚': { Result = ConvertToCodepoints("cliff (がんだれ)"); } break;
    //    case L'⼛': { Result = ConvertToCodepoints("private, Katakana Mu (む)"); } break;
    //    case L'⼜': { Result = ConvertToCodepoints("again, right hand (また)"); } break;
    //    case L'⼝': { Result = ConvertToCodepoints("mouth (くち)"); } break;
    //    case L'': { Result = ConvertToCodepoints("mouth (くちへん)"); } break;
    //    case L'⼞': { Result = ConvertToCodepoints("border, territorial boundaries (くにがまえ)"); } break;
    //    case L'⼟': { Result = ConvertToCodepoints("earth (つち)"); } break;
    //    case L'': { Result = ConvertToCodepoints("earth (つちへん)"); } break;
    //    case L'⼠': { Result = ConvertToCodepoints("man, scholar, samurai (さむらい)"); } break;
    //    case L'': { Result = ConvertToCodepoints("man, scholar, samurai (さむらいかんむり)"); } break;
    //    case L'⼡': { Result = ConvertToCodepoints("to follow (のまた)"); } break;
    //    case L'⼢': { Result = ConvertToCodepoints("to go slowly (なつあし)"); } break;
    //    case L'⼣': { Result = ConvertToCodepoints("evening (ゆうべ)"); } break;
    //    case L'⼤': { Result = ConvertToCodepoints("large, big (だい)"); } break;
    //    case L'⼥': { Result = ConvertToCodepoints("woman (おんな)"); } break;
    //    case L'': { Result = ConvertToCodepoints("woman (おんなへん)"); } break;
    //    case L'⼦': { Result = ConvertToCodepoints("child, son (こ)"); } break;
    //    case L'': { Result = ConvertToCodepoints("child, son (こへん)"); } break;
    //    case L'⼧': { Result = ConvertToCodepoints("roof, house (うかんむり)"); } break;
    //    case L'⼨': { Result = ConvertToCodepoints("inch, (2.25 cm) (すん)"); } break;
    //    case L'': { Result = ConvertToCodepoints("inch, (2.25 cm) (すんづくり)"); } break;
    //    case L'⼩': { Result = ConvertToCodepoints("small (しょう)"); } break;
    //    case L'⺌': { Result = ConvertToCodepoints("small (しょうかんむり)"); } break;
    //    case L'⺐': { Result = ConvertToCodepoints("lame leg (だいのまげあし)"); } break;
    //    case L'⼫': { Result = ConvertToCodepoints("corpse, awning (しかばね)"); } break;
    //    case L'⼬': { Result = ConvertToCodepoints("sprout (くさのめ)"); } break;
    //    case L'⼭': { Result = ConvertToCodepoints("mountain (やま)"); } break;
    //    case L'': { Result = ConvertToCodepoints("mountain (やまへん)"); } break;
    //    case L'': { Result = ConvertToCodepoints("mountain (やまかんむり)"); } break;
    //    case L'⼮': { Result = ConvertToCodepoints("winding river (まがりがわ)"); } break;
    //    case L'川': { Result = ConvertToCodepoints("river (さんぼんがわ)"); } break;
    //    case L'⼯': { Result = ConvertToCodepoints("work, carpenter, skill (たくみ)"); } break;
    //    case L'': { Result = ConvertToCodepoints("work, carpenter, skill (たくみへん)"); } break;
    //    case L'⼰': { Result = ConvertToCodepoints("self (おのれ)"); } break;
    //    case L'⼱': { Result = ConvertToCodepoints("cloth (はば)"); } break;
    //    case L'': { Result = ConvertToCodepoints("cloth (はばへん)"); } break;
    //    case L'⼲': { Result = ConvertToCodepoints("to dry, shield (かん)"); } break;
    //    case L'⺓': { Result = ConvertToCodepoints("young, slight (いとがしら)"); } break;
    //    case L'⼴': { Result = ConvertToCodepoints("slanting roof (まだれ)"); } break;
    //    case L'⼵': { Result = ConvertToCodepoints("to move, stretch (えんにょう)"); } break;
    //    case L'⼶': { Result = ConvertToCodepoints("folded hands (にじゅうあし)"); } break;
    //    case L'⼷': { Result = ConvertToCodepoints("javelin (いぐるみ)"); } break;
    //    case L'⼸': { Result = ConvertToCodepoints("bow （in archery） (ゆみ)"); } break;
    //    case L'': { Result = ConvertToCodepoints("bow （in archery） (ゆみへん)"); } break;
    //    case L'⼹': { Result = ConvertToCodepoints("pig’s head (けいがしら)"); } break;
    //    case L'⺕': { Result = ConvertToCodepoints("pig’s head (けいがしら)"); } break;
    //    case L'⺔': { Result = ConvertToCodepoints("pig’s head (けいがしら)"); } break;
    //    case L'⼺': { Result = ConvertToCodepoints("hair-style, light rays (さんづくり)"); } break;
    //    case L'⼻': { Result = ConvertToCodepoints("step, stride, street, to go (ぎょうにんべん)"); } break;
    //    case L'⺾': { Result = ConvertToCodepoints("grass (くさかんむり)"); } break;
    //    case L'⻌': { Result = ConvertToCodepoints("road, walk, to advance (しんにょう)"); } break;
    //    case L'⻏': { Result = ConvertToCodepoints("village, country, city (おおざと)"); } break;
    //    case L'⻖': { Result = ConvertToCodepoints("hill, mound (こざとへん)"); } break;
    //    case L'⺍': { Result = ConvertToCodepoints("Katakana Tsu (つ)"); } break;
    //    case L'⺖': { Result = ConvertToCodepoints("heart, mind, spirit (りっしんべん)"); } break;
    //    case L'⺘': { Result = ConvertToCodepoints("hand (てへん)"); } break;
    //    case L'⺡': { Result = ConvertToCodepoints("water (さんずい)"); } break;
    //    case L'⺨': { Result = ConvertToCodepoints("beast (けものへん)"); } break;
    //    case L'⼼': { Result = ConvertToCodepoints("heart, mind, spirit (こころ)"); } break;
    //    case L'⺗': { Result = ConvertToCodepoints("heart, mind, spirit (したごころ)"); } break;
    //    case L'⼽': { Result = ConvertToCodepoints("spear, weapon (ほこ)"); } break;
    //    case L'⼾': { Result = ConvertToCodepoints("door (と)"); } break;
    //    case L'': { Result = ConvertToCodepoints("door (とだれ)"); } break;
    //    case L'⼿': { Result = ConvertToCodepoints("hand (て)"); } break;
    //    case L'⽀': { Result = ConvertToCodepoints("branch (しにょう)"); } break;
    //    case L'⽁': { Result = ConvertToCodepoints("activity, to strike, hit (ぼくづくり)"); } break;
    //    case L'⺙': { Result = ConvertToCodepoints("activity, to strike, hit (ぼくづくり)"); } break;
    //    case L'⽂': { Result = ConvertToCodepoints("literature, letters (ぶん)"); } break;
    //    case L'⽃': { Result = ConvertToCodepoints("big dipper, ladle, 18 liters (ますづくり)"); } break;
    //    case L'⽄': { Result = ConvertToCodepoints("axe (おのづくり)"); } break;
    //    case L'⽅': { Result = ConvertToCodepoints("direction, flag (ほう)"); } break;
    //    case L'': { Result = ConvertToCodepoints("direction, flag (ほうへん)"); } break;
    //    case L'⽆': { Result = ConvertToCodepoints("not (むにょう)"); } break;
    //    case L'⽇': { Result = ConvertToCodepoints("sun, day, time (ひ)"); } break;
    //    case L'': { Result = ConvertToCodepoints("sun, day, time (ひへん)"); } break;
    //    case L'⽈': { Result = ConvertToCodepoints("to say (ひらび)"); } break;
    //    case L'⽉': { Result = ConvertToCodepoints("moon, month, period (つき)"); } break;
    //    case L'⺝': { Result = ConvertToCodepoints("moon, month, period (つきへん)"); } break;
    //    case L'': { Result = ConvertToCodepoints("meat, flesh (にくづき)"); } break;
    //    case L'⽊': { Result = ConvertToCodepoints("tree, wood (き)"); } break;
    //    case L'': { Result = ConvertToCodepoints("tree, wood (きへん)"); } break;
    //    case L'⽋': { Result = ConvertToCodepoints("to lack, yawn (あくび)"); } break;
    //    case L'⽌': { Result = ConvertToCodepoints("to stop (とめる)"); } break;
    //    case L'⽍': { Result = ConvertToCodepoints("death & dying, to decompose (がつ)"); } break;
    //    case L'': { Result = ConvertToCodepoints("death & dying, to decompose (がつへん)"); } break;
    //    case L'⽎': { Result = ConvertToCodepoints("lance shaft, action (るまた)"); } break;
    //    case L'⽏': { Result = ConvertToCodepoints("not, mother (なかれ)"); } break;
    //    case L'⽐': { Result = ConvertToCodepoints("to compare (くらべる)"); } break;
    //    case L'⽑': { Result = ConvertToCodepoints("hair (け)"); } break;
    //    case L'⽒': { Result = ConvertToCodepoints("family, clan (うじ)"); } break;
    //    case L'⽓': { Result = ConvertToCodepoints("steam, air (きがまえ)"); } break;
    //    case L'⽔': { Result = ConvertToCodepoints("water (みず)"); } break;
    //    case L'⽕': { Result = ConvertToCodepoints("fire (ひ)"); } break;
    //    case L'': { Result = ConvertToCodepoints("fire (ひへん)"); } break;
    //    case L'⺣': { Result = ConvertToCodepoints("fire (れっか)"); } break;
    //    case L'⽖': { Result = ConvertToCodepoints("claw, nail (つめ)"); } break;
    //    case L'⺤': { Result = ConvertToCodepoints("claw, nail (つめかんむり)"); } break;
    //    case L'爫': { Result = ConvertToCodepoints("claw, nail (つめかんむり)"); } break;
    //    case L'⽗': { Result = ConvertToCodepoints("father (ちち)"); } break;
    //    case L'⽘': { Result = ConvertToCodepoints("to mix (こう)"); } break;
    //    case L'⽙': { Result = ConvertToCodepoints("split wood (しょうへん)"); } break;
    //    case L'⽚': { Result = ConvertToCodepoints("split wood (かた)"); } break;
    //    case L'': { Result = ConvertToCodepoints("split wood (かたへん)"); } break;
    //    case L'': { Result = ConvertToCodepoints("fang, canine tooth (きば)"); } break;
    //    case L'⽜': { Result = ConvertToCodepoints("cow (うし)"); } break;
    //    case L'': { Result = ConvertToCodepoints("cow (うしへん)"); } break;
    //    case L'⽝': { Result = ConvertToCodepoints("dog (いぬ)"); } break;
    //    case L'': { Result = ConvertToCodepoints("jewelry, jeweled king (おうへん)"); } break;
    //    case L'⺭': { Result = ConvertToCodepoints("altar, festival, religious service (しめすへん)"); } break;
    //    case L'㓁': { Result = ConvertToCodepoints("net (あみがしら)"); } break;
    //    case L'⺹': { Result = ConvertToCodepoints("old, old-age (おいかんむり)"); } break;
    //    case L'⽞': { Result = ConvertToCodepoints("darkness (げん)"); } break;
    //    case L'⽟': { Result = ConvertToCodepoints("jewelry (たま)"); } break;
    //    case L'': { Result = ConvertToCodepoints("melon (うり)"); } break;
    //    case L'⽡': { Result = ConvertToCodepoints("tile (かわら)"); } break;
    //    case L'⽢': { Result = ConvertToCodepoints("sweet (あまい)"); } break;
    //    case L'⽣': { Result = ConvertToCodepoints("birth, to be born, live (うまれる)"); } break;
    //    case L'⽤': { Result = ConvertToCodepoints("to use (もちいる)"); } break;
    //    case L'⽥': { Result = ConvertToCodepoints("rice paddy (た)"); } break;
    //    case L'': { Result = ConvertToCodepoints("rice paddy (たへん)"); } break;
    //    case L'⽦': { Result = ConvertToCodepoints("bolt of cloth (ひき)"); } break;
    //    case L'⺪': { Result = ConvertToCodepoints("bolt of cloth (ひきへん)"); } break;
    //    case L'⽧': { Result = ConvertToCodepoints("sickness (やまいだれ)"); } break;
    //    case L'⽨': { Result = ConvertToCodepoints("outspread legs, departure (はつがしら)"); } break;
    //    case L'⽩': { Result = ConvertToCodepoints("white (しろ)"); } break;
    //    case L'': { Result = ConvertToCodepoints("white (はくへん)"); } break;
    //    case L'⽪': { Result = ConvertToCodepoints("skin, hide (けがわ)"); } break;
    //    case L'⽫': { Result = ConvertToCodepoints("plate, bowl (さら)"); } break;
    //    case L'⽬': { Result = ConvertToCodepoints("eye (め)"); } break;
    //    case L'': { Result = ConvertToCodepoints("eye (めへん)"); } break;
    //    case L'': { Result = ConvertToCodepoints("eye (よこめ)"); } break;
    //    case L'⽭': { Result = ConvertToCodepoints("halberd (ほこ)"); } break;
    //    case L'': { Result = ConvertToCodepoints("halberd (ほこへん)"); } break;
    //    case L'⽮': { Result = ConvertToCodepoints("arrow (や)"); } break;
    //    case L'': { Result = ConvertToCodepoints("arrow (やへん)"); } break;
    //    case L'⽯': { Result = ConvertToCodepoints("stone (いし)"); } break;
    //    case L'': { Result = ConvertToCodepoints("stone (いしへん)"); } break;
    //    case L'⽰': { Result = ConvertToCodepoints("altar, festival, religious service (しめす)"); } break;
    //    case L'⽱': { Result = ConvertToCodepoints("footprint (じゅうのあし)"); } break;
    //    case L'⽲': { Result = ConvertToCodepoints("grain (のぎへん)"); } break;
    //    case L'⽳': { Result = ConvertToCodepoints("hole, cave (あな)"); } break;
    //    case L'': { Result = ConvertToCodepoints("hole, cave (あなかんむり)"); } break;
    //    case L'⽴': { Result = ConvertToCodepoints("to stand (たつ)"); } break;
    //    case L'': { Result = ConvertToCodepoints("to stand (たつへん)"); } break;
    //    case L'': { Result = ConvertToCodepoints("fang, canine tooth (きば)"); } break;
    //    case L'': { Result = ConvertToCodepoints("fang, canine tooth (きばへん)"); } break;
    //    case L'氺': { Result = ConvertToCodepoints("water (したみず)"); } break;
    //    case L'⺫': { Result = ConvertToCodepoints("net (あみがしら)"); } break;
    //    //case L'𦉰': { Result = ConvertToCodepoints("net (あみがしら)"); } break;
    //    case L'⻂': { Result = ConvertToCodepoints("clothing (ころもへん)"); } break;
    //    case L'⺛': { Result = ConvertToCodepoints("not (むにょう)"); } break;
    //    case L'⽵': { Result = ConvertToCodepoints("bamboo (たけ)"); } break;
    //    case L'⺮': { Result = ConvertToCodepoints("bamboo (たけかんむり)"); } break;
    //    case L'⽶': { Result = ConvertToCodepoints("rice (こめ)"); } break;
    //    case L'': { Result = ConvertToCodepoints("rice (こめへん)"); } break;
    //    case L'⽷': { Result = ConvertToCodepoints("thread (いと)"); } break;
    //    case L'': { Result = ConvertToCodepoints("thread (いとへん)"); } break;
    //    case L'⽸': { Result = ConvertToCodepoints("earthen jar (みずがめ)"); } break;
    //    case L'⽹': { Result = ConvertToCodepoints("net (あみめ)"); } break;
    //    case L'⽺': { Result = ConvertToCodepoints("sheep (ひつじ)"); } break;
    //    case L'⺷': { Result = ConvertToCodepoints("sheep (ひつじ)"); } break;
    //    case L'羽': { Result = ConvertToCodepoints("feather, wing (はね)"); } break;
    //    case L'⽻': { Result = ConvertToCodepoints("feather, wing (はね)"); } break;
    //    case L'⽼': { Result = ConvertToCodepoints("old, old-age (おいかんむり)"); } break;
    //    case L'⽽': { Result = ConvertToCodepoints("and also (しこうして)"); } break;
    //    case L'⽾': { Result = ConvertToCodepoints("plow (らいすき)"); } break;
    //    case L'⽿': { Result = ConvertToCodepoints("ear (みみ)"); } break;
    //    case L'': { Result = ConvertToCodepoints("ear (みみへん)"); } break;
    //    case L'⾀': { Result = ConvertToCodepoints("writing brush (ふでづくり)"); } break;
    //    case L'⾁': { Result = ConvertToCodepoints("flesh, meat (にく)"); } break;
    //    case L'⾂': { Result = ConvertToCodepoints("retainer, minister (しん)"); } break;
    //    case L'⾃': { Result = ConvertToCodepoints("self (みずから)"); } break;
    //    case L'⾄': { Result = ConvertToCodepoints("to arrive, reach (いたる)"); } break;
    //    case L'': { Result = ConvertToCodepoints("to arrive, reach (いたるへん)"); } break;
    //    case L'⾅': { Result = ConvertToCodepoints("mortar, quern (うす)"); } break;
    //    case L'⾆': { Result = ConvertToCodepoints("tongue (した)"); } break;
    //    case L'⾇': { Result = ConvertToCodepoints("contrary, to err (まいあし)"); } break;
    //    case L'⾈': { Result = ConvertToCodepoints("ship, boat (ふね)"); } break;
    //    case L'': { Result = ConvertToCodepoints("ship, boat (ふねへん)"); } break;
    //    case L'⾉': { Result = ConvertToCodepoints("boundary (こん)"); } break;
    //    case L'⾊': { Result = ConvertToCodepoints("color (いろ)"); } break;
    //    case L'⾋': { Result = ConvertToCodepoints("grass, plant (くさ)"); } break;
    //    case L'⾌': { Result = ConvertToCodepoints("tiger (とらがしら)"); } break;
    //    case L'⾍': { Result = ConvertToCodepoints("worm, insect, bug (むし)"); } break;
    //    case L'': { Result = ConvertToCodepoints("worm, insect, bug (むしへん)"); } break;
    //    case L'⾎': { Result = ConvertToCodepoints("blood (ち)"); } break;
    //    case L'⾏': { Result = ConvertToCodepoints("to go (ぎょうがまえ)"); } break;
    //    case L'⾐': { Result = ConvertToCodepoints("clothing (ころも)"); } break;
    //    case L'⾑': { Result = ConvertToCodepoints("cover, west (にし)"); } break;
    //    case L'⻃': { Result = ConvertToCodepoints("cover, west (にし)"); } break;
    //    case L'⽠': { Result = ConvertToCodepoints("melon (うり)"); } break;
    //    case L'⾒': { Result = ConvertToCodepoints("to see (みる)"); } break;
    //    case L'⾓': { Result = ConvertToCodepoints("horn, corner (つの)"); } break;
    //    case L'': { Result = ConvertToCodepoints("horn, corner (つのへん)"); } break;
    //    case L'⾔': { Result = ConvertToCodepoints("words, to speak, say (げん)"); } break;
    //    case L'': { Result = ConvertToCodepoints("words, to speak, say (ごんべん)"); } break;
    //    case L'⾕': { Result = ConvertToCodepoints("valley (たに)"); } break;
    //    case L'': { Result = ConvertToCodepoints("valley (たにへん)"); } break;
    //    case L'⾖': { Result = ConvertToCodepoints("bean (まめ)"); } break;
    //    case L'': { Result = ConvertToCodepoints("bean (まめへん)"); } break;
    //    case L'⾗': { Result = ConvertToCodepoints("pig (いのこ)"); } break;
    //    case L'⾘': { Result = ConvertToCodepoints("badger (むじなへん)"); } break;
    //    case L'⾙': { Result = ConvertToCodepoints("shell, property, wealth (かい)"); } break;
    //    case L'': { Result = ConvertToCodepoints("shell, property, wealth (かいへん)"); } break;
    //    case L'⾚': { Result = ConvertToCodepoints("red (あか)"); } break;
    //    case L'⾛': { Result = ConvertToCodepoints("to run (はしる)"); } break;
    //    case L'': { Result = ConvertToCodepoints("to run (そうにょう)"); } break;
    //    case L'⾜': { Result = ConvertToCodepoints("foot, leg (あし)"); } break;
    //    case L'⻊': { Result = ConvertToCodepoints("foot, leg (あしへん)"); } break;
    //    case L'⾝': { Result = ConvertToCodepoints("body (み)"); } break;
    //    case L'': { Result = ConvertToCodepoints("body (みへん)"); } break;
    //    case L'⾞': { Result = ConvertToCodepoints("vehicle, wheel, car (くるま)"); } break;
    //    case L'': { Result = ConvertToCodepoints("vehicle, wheel, car (くるまへん)"); } break;
    //    case L'⾟': { Result = ConvertToCodepoints("bitter (からい)"); } break;
    //    case L'⾠': { Result = ConvertToCodepoints("Fifth zodiac sign, 7–9 A.M. (しんのたつ)"); } break;
    //    case L'⾡': { Result = ConvertToCodepoints("to advance, move ahead (しんにょう)"); } break;
    //    case L'⾢': { Result = ConvertToCodepoints("community (むら)"); } break;
    //    case L'⾣': { Result = ConvertToCodepoints("sake jar, bird (ひよみのとり)"); } break;
    //    case L'': { Result = ConvertToCodepoints("sake jar, bird (とりへん)"); } break;
    //    case L'⾤': { Result = ConvertToCodepoints("to separate (のごめ)"); } break;
    //    case L'': { Result = ConvertToCodepoints("to separate (のごめへん)"); } break;
    //    case L'⾥': { Result = ConvertToCodepoints("village, (3.93 km) (さと)"); } break;
    //    case L'': { Result = ConvertToCodepoints("village, (3.93 km) (さとへん)"); } break;
    //    case L'': { Result = ConvertToCodepoints("contrary, to err (まいあし)"); } break;
    //    case L'⻨': { Result = ConvertToCodepoints("wheat (むぎ)"); } break;
    //    case L'⾦': { Result = ConvertToCodepoints("metal, gold, mineral (かね)"); } break;
    //    case L'': { Result = ConvertToCodepoints("metal, gold, mineral (かねへん)"); } break;
    //    case L'⻑': { Result = ConvertToCodepoints("long (ながい)"); } break;
    //    case L'⾨': { Result = ConvertToCodepoints("gate, door (もんがまえ)"); } break;
    //    case L'⾩': { Result = ConvertToCodepoints("hill (こざと)"); } break;
    //    case L'⾪': { Result = ConvertToCodepoints("to capture (れいづくり)"); } break;
    //    case L'⾫': { Result = ConvertToCodepoints("small bird (ふるとり)"); } break;
    //    case L'⾬': { Result = ConvertToCodepoints("rain (あめ)"); } break;
    //    case L'⻗': { Result = ConvertToCodepoints("rain (あめかんむり)"); } break;
    //    case L'⾭': { Result = ConvertToCodepoints("blue, green (あお)"); } break;
    //    case L'⻘': { Result = ConvertToCodepoints("blue, green (あお)"); } break;
    //    case L'⾮': { Result = ConvertToCodepoints("wrong, non- (あらず)"); } break;
    //    case L'⻟': { Result = ConvertToCodepoints("food, to eat (しょくへん)"); } break;
    //    case L'⻫': { Result = ConvertToCodepoints("alike (せい)"); } break;
    //    case L'⾯': { Result = ConvertToCodepoints("face, surface (めん)"); } break;
    //    case L'⾰': { Result = ConvertToCodepoints("leather (つくりがわ)"); } break;
    //    case L'': { Result = ConvertToCodepoints("leather (なめしがわ)"); } break;
    //    case L'⾲': { Result = ConvertToCodepoints("leek (にら)"); } break;
    //    case L'⾳': { Result = ConvertToCodepoints("sound, noise (おと)"); } break;
    //    case L'⾴': { Result = ConvertToCodepoints("head, page (おおがい)"); } break;
    //    case L'⾵': { Result = ConvertToCodepoints("wind (かぜ)"); } break;
    //    case L'⾶': { Result = ConvertToCodepoints("to fly (とぶ)"); } break;
    //    case L'⾷': { Result = ConvertToCodepoints("food, to eat (しょく)"); } break;
    //    case L'⾸': { Result = ConvertToCodepoints("head (くび)"); } break;
    //    case L'⾹': { Result = ConvertToCodepoints("scent (かおり)"); } break;
    //    case L'⾺': { Result = ConvertToCodepoints("horse (うま)"); } break;
    //    case L'': { Result = ConvertToCodepoints("horse (うまへん)"); } break;
    //    case L'⾻': { Result = ConvertToCodepoints("bone (ほね)"); } break;
    //    case L'': { Result = ConvertToCodepoints("bone (ほねへん)"); } break;
    //    case L'⾼': { Result = ConvertToCodepoints("high (たかい)"); } break;
    //    case L'⾽': { Result = ConvertToCodepoints("long hair (かみかんむり)"); } break;
    //    case L'⾾': { Result = ConvertToCodepoints("fighting (たたかいがまえ)"); } break;
    //    case L'⾿': { Result = ConvertToCodepoints("herbs (においざけ)"); } break;
    //    case L'⿀': { Result = ConvertToCodepoints("tripod (れき)"); } break;
    //    case L'⿁': { Result = ConvertToCodepoints("demon (おに)"); } break;
    //    case L'⾱': { Result = ConvertToCodepoints("leather (なめしがわ)"); } break;
    //    case L'⿂': { Result = ConvertToCodepoints("fish (うお)"); } break;
    //    case L'': { Result = ConvertToCodepoints("fish (うおへん)"); } break;
    //    case L'⿃': { Result = ConvertToCodepoints("bird (とり)"); } break;
    //    case L'⿄': { Result = ConvertToCodepoints("salt (しお)"); } break;
    //    case L'⿅': { Result = ConvertToCodepoints("deer (しか)"); } break;
    //    case L'⿆': { Result = ConvertToCodepoints("wheat (むぎ)"); } break;
    //    case L'⿇': { Result = ConvertToCodepoints("hemp (あさ)"); } break;
    //    case L'': { Result = ConvertToCodepoints("hemp (あさかんむり)"); } break;
    //    case L'⻩': { Result = ConvertToCodepoints("yellow (き)"); } break;
    //    case L'黒': { Result = ConvertToCodepoints("black (くろ)"); } break;
    //    case L'⻲': { Result = ConvertToCodepoints("turtle (かめ)"); } break;
    //    case L'⿈': { Result = ConvertToCodepoints("yellow (き)"); } break;
    //    case L'⿉': { Result = ConvertToCodepoints("millet (きび)"); } break;
    //    case L'⿊': { Result = ConvertToCodepoints("black (くろ)"); } break;
    //    case L'⿋': { Result = ConvertToCodepoints("embroider (ぬいとり)"); } break;
    //    case L'⻭': { Result = ConvertToCodepoints("tooth (は)"); } break;
    //    case L'⿌': { Result = ConvertToCodepoints("frog (かえる)"); } break;
    //    case L'⿍': { Result = ConvertToCodepoints("tripod (かなえ)"); } break;
    //    case L'⿎': { Result = ConvertToCodepoints("drum (つづみ)"); } break;
    //    case L'⿏': { Result = ConvertToCodepoints("rat, mouse (ねずみ)"); } break;
    //    case L'⿐': { Result = ConvertToCodepoints("nose (はな)"); } break;
    //    case L'⿑': { Result = ConvertToCodepoints("alike (せい)"); } break;
    //    case L'⿒': { Result = ConvertToCodepoints("tooth (は)"); } break;
    //    case L'⿓': { Result = ConvertToCodepoints("dragon (りゅう)"); } break;
    //    case L'⿔': { Result = ConvertToCodepoints("turtle (かめ)"); } break;
    //    case L'⿕': { Result = ConvertToCodepoints("flute (やく)"); } break;
    //    case L'々': { Result = ConvertToCodepoints("n/a (n/a)"); } break;
    //    default: {}
    //}
    //return Result;
}
#else
#endif

internal b32
CheckButton__(text_render_queue *RenderQueue, v2 MousePos, rect ButtonBoundingBox, v4 ActiveBorderColor, v4 InactiveBorderColor)
{
    b32 Hovered = 
        ((MousePos.x >= ButtonBoundingBox.BottomLeft.x) && (MousePos.x <= ButtonBoundingBox.TopRight.x) &&
         (MousePos.y >= ButtonBoundingBox.BottomLeft.y) && (MousePos.y <= ButtonBoundingBox.TopRight.y));
    v4 BorderColor = Hovered ? ActiveBorderColor : InactiveBorderColor;
    if(BorderColor.a)
    {
        PushBackground(RenderQueue, ButtonBoundingBox, BorderColor);
    }
    return Hovered;
}

#define _CheckButtonArg(_1, _2, _3, N, ...) N
#define CheckButton_1(ButtonBoundingBox) CheckButton__(&RenderQueue, MousePos, (ButtonBoundingBox), Transparent, Transparent)
#define CheckButton_2(ButtonBoundingBox, BorderColor) CheckButton__(&RenderQueue, MousePos, (ButtonBoundingBox), (BorderColor), (BorderColor))
#define CheckButton_3(ButtonBoundingBox, ActiveBorderColor, InactiveBorderColor) CheckButton__(&RenderQueue, MousePos, (ButtonBoundingBox), (ActiveBorderColor), (InactiveBorderColor))

#define CheckButton(...) _CheckButtonArg(__VA_ARGS__, CheckButton_3, CheckButton_2, CheckButton_1)(__VA_ARGS__)

internal void
DrawSelectedWordInfo(kmap_state *State, text_render_queue *RenderQueue, f32 UiLineHeight, f32 KanjiUiHeight)
{
    // draw selected word
    u32 SelectedWordIndex = State->Lines[State->SelectedWordPosition].WordIndex;
    rect WordBoundingBox = GetWordBoundingBox(State, SelectedWordIndex);
    WordBoundingBox.BottomLeft = WorldToPixelSpace(WordBoundingBox.BottomLeft, State->Camera);
    WordBoundingBox.TopRight = WorldToPixelSpace(WordBoundingBox.TopRight, State->Camera);
    DrawWordDictionaryInfo(State, RenderQueue, UiLineHeight, KanjiUiHeight, SelectedWordIndex, WordBoundingBox);
}

typedef struct
{
    rect Area;
    v4 Color;
    //button_callback *Callback;
} button_description;

#define MAX_BUTTON_COUNT 1024
typedef struct
{
    u32 ButtonCount;
    button_description *Buttons;
} buttons;

// New interface design:
// screen is divided into 2 parts: filter and matches, like this:
// ----------------------------------------------
// | 人気  | にんげん (also written as ...) <) (>
// | 人間 <| 1. person                          |
// | 人口  | 2. human                           |
// | ...   |    ...                             |
// ----------------------------------------------
// |    音   訓   Meaning  Radicals             |
// | 人 にん ひと ...      人                   |
// |    じん ...                                |
// |    ...                                     |
// ----------------------------------------------
// Then, the matches themselves are presented as writing + dictionary info.
// The top-right arrows allow the user to go to his previous/next query.
//
// The next thing to do would be to allow different types of filters:
// radicals, parts of speech, bookmarks etc.

// giant TODO list:
//
// - figure out a better way to navigate the map.
//   Right now we can move around manually or to the words that are connected to the currently selected character,
//   but we want to give the user some kind of preview of some of the words connected to our word.
//   The problem is, there's too many words containing some of the more popular characters
//   (the biggest offender, 人, is a part of over 2900 words!)
//
// Architecture/bugs
// - more intuitive zoom behavior (right now zoom is not absolute, but dependent on the size of the texture atlas)
// - smooth zooming
// - it looks like we have a memory leak?
// - rework the printer
// - get rid of ConvertToCodepoints everywhere
// - get the background inflation logic out of the shader
// - try out the "occupied regions" idea for the ui
// - get rid of the GetRealWordBoundingBox related cruft
// - get rid of uniform buffers since they bump our opengl requirements for no reason
// - allow user to see kanji connections while inside bookmark layers
// - cleanup of the pre-true-ui cruft
// - polish button system (i really should've called them active
// regions after all...)
// - convert all radicals into kangxi form 
// (right now it's a mix of proper forms, kanji and weird things like U+FF5C for the vertical line radical)
// - get rid of stupid layers
//
// Features
// - try "real" chunks
// - other dictionary formats
// - jumping to words connected to the selected via mouse (if the word count is less than N)
// - ability to see info for multiple kanji
// - a way to present words with more than one writing
// - try out distance fields for fonts
// - draw pronounciations as furigana
// - jump history
// - multi-selection
// - more filtering options (filter by flags, regex)
// - multiple languages
// - upgrade the converter to detect which word info corresponds to which reading/meaning
// - get the japanese variant of the font from the collection (parse the font's "name" table)
RENDER_FRAME(RenderFrame)
{
    StartTimingFunc();
    kmap_state *State = (kmap_state *)Memory->Base;

    if(!State->Initialized)
    {
        StartTiming(StateInit);

        StartTiming(Tests);
        {
#define TestUtf8String(CString) \
            { \
                char TestString[] = (CString); \
                codepoints TestCodepoints = ConvertToCodepoints(TestString); \
                char Encoded[256] = {0}; \
                size_t EncodedSize = EncodeCodepointsToUtf8(TestCodepoints, Encoded, sizeof(Encoded)); \
                Assert(EncodedSize == sizeof(TestString)); \
                for(u32 CharacterIndex = 0; CharacterIndex < EncodedSize; ++CharacterIndex) \
                { \
                    Assert(Encoded[CharacterIndex] == TestString[CharacterIndex]); \
                } \
            }
            TestUtf8String("123 abc");
            TestUtf8String("Р");
            TestUtf8String("Работа");
            TestUtf8String("令和");
            TestUtf8String("😂");
        }
        EndTiming(Tests);

        State->Arena = InitializeArena(Memory->Base + sizeof(kmap_state), Memory->Size - sizeof(kmap_state));
        State->FrameArena = Subarena(&State->Arena, Megabytes(1));
        State->WordArena = Subarena(&State->Arena, Megabytes(1));
        State->SearchArena = Subarena(&State->Arena, Megabytes(16));
        // set the platform functions
        Platform = Memory->Platform;

        StartTiming(InitOpenGL);

#if BUILD_INTERNAL
        LoadOpenGlExtensions();
        // debugging
        int ContextFlags;
        glGetIntegerv(GL_CONTEXT_FLAGS, &ContextFlags);
        if(!(ContextFlags & GL_CONTEXT_FLAG_DEBUG_BIT))
        {
            Die("Couldn't initialize debugging...\n");
        }
        glEnable(GL_DEBUG_OUTPUT);
        glDebugMessageCallback(GLDebugCallback, 0);
        glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0, 0, GL_TRUE);
#endif

        glEnable(GL_DEPTH_TEST);
        glDepthFunc(GL_GEQUAL);
        glClearDepth(0.f);

        EndTiming(InitOpenGL);

        kmdb_header *KmdbHeader = (kmdb_header *)GlobalDatabaseBytes;

        Assert(KmdbHeader->Magic == KMDB_MAGIC);
        Assert(KmdbHeader->Version <= KMDB_CURRENT_VERSION);

        State->WordCount = KmdbHeader->WordCount;
        State->KanjiHashtable.KanjiCount = KmdbHeader->KanjiCount;
        State->KanjiHashtable.KanjiInfos = (kanji_info *)(GlobalDatabaseBytes + KmdbHeader->KanjiHashtableOffset);
        State->KanjiHashtable.Data = GlobalDatabaseBytes + KmdbHeader->KanjiDataOffset;

        kmdb_word_description *WordDescriptions = (kmdb_word_description *)(GlobalDatabaseBytes + KmdbHeader->WordDescriptionsOffset);
        char *WordData = (char *)(GlobalDatabaseBytes + KmdbHeader->WordDataOffset);
        State->Words = PushStaticArray(&State->Arena, word, State->WordCount);

        for(u32 WordIndex = 0; WordIndex < State->WordCount; ++WordIndex)
        {
            kmdb_word_description *WordDescription = WordDescriptions + WordIndex;
            word *Word = State->Words + WordIndex;
            Word->Writing = WordData + WordDescription->WritingOffset;

            Word->ReadingCount = WordDescription->ReadingCount;
            Word->Readings = WordData + WordDescription->ReadingOffset;

            Word->MeaningCount = WordDescription->MeaningCount;
            Word->Meanings = WordData + WordDescription->MeaningOffset;

            Word->FlagCount = WordDescription->FlagCount;
            Word->Flags = (u8 *)(WordData + WordDescription->FlagOffset);
        }

#if 0
        // test
        u32 *DisputedCounts = PushStaticArray(&State->Arena, u32, State->KanjiHashtable.KanjiCount);
        u32 *UndisputedCounts = PushStaticArray(&State->Arena, u32, State->KanjiHashtable.KanjiCount);
        u32 MaxLength = 0;

        for(u32 Hash = 0; Hash < State->KanjiHashtable.KanjiCount; ++Hash)
        {
            u32 DisputedSquares = 0,
                UndisputedSquares = 0;
            kanji_info *Info = State->KanjiHashtable.KanjiInfos + Hash;
            kanji_data Data = KanjiInfoToKanjiData(&State->KanjiHashtable, Info);
            for(u32 Wordi = 0; Wordi < Data.WordCount; ++Wordi)
            {
                word *Word = State->Words + Data.WordIndices[Wordi];
                codepoints Writing = ConvertToCodepoints(Word->Writing);
                MaxLength = Maximum(Writing.Count, MaxLength);
                b32 Disputed = false;
                for(u32 Codepointi = 0; Codepointi < Writing.Count; ++Codepointi)
                {
                    c32 Codepoint = Writing.Data[Codepointi];
                    if((IsKanji(Codepoint)) && (Codepoint != Info->Codepoint))
                    {
                        Disputed = true;
                        break;
                    }
                }
                if(Disputed)
                {
                    DisputedSquares += Writing.Count;
                }
                else
                {
                    UndisputedSquares += Writing.Count;
                }
            }
            printf("%lc: %d disputed squares, %d undisputed squares\n", (wchar_t)Info->Codepoint, DisputedSquares, UndisputedSquares);
        }
        printf("max word length: %d\n", MaxLength);
        exit(0);
#else
#endif

#if 0
        // test
        c32 *UniqRadicals = StartDynamicArray(&State->Arena, c32);
        for(u32 Hash = 0; Hash < State->KanjiHashtable.KanjiCount; ++Hash)
        {
            kanji_info *Storage = State->KanjiHashtable.KanjiInfos + Hash;
            u8 RadicalCount = Storage->RadicalCount;
            c32 *Radicals = (c32 *)(State->KanjiHashtable.Data + Storage->RadicalOffset);
            for(u32 RadicalIndex = 0; RadicalIndex < RadicalCount; ++RadicalIndex)
            {
                c32 Radical = Radicals[RadicalIndex];
                for(u32 UniqRadicalIndex = 0; UniqRadicalIndex < State->Arena.ArrayCount; ++UniqRadicalIndex)
                {
                    if(UniqRadicals[UniqRadicalIndex] == Radical)
                    {
                        goto NextIter;
                    }
                }
                PushElement(&State->Arena, Radical);
NextIter:
            }
        }
        u32 UniqRadicalCount = EndDynamicArray(&State->Arena);
        for(u32 UniqRadicalIndex = 0; UniqRadicalIndex < UniqRadicalCount; ++UniqRadicalIndex)
        {
            printf("u+%x\n", UniqRadicals[UniqRadicalIndex]);
        }
        exit(0);
#else
#endif

        // create shader programs
        StartTiming(InitShaders);
#if BUILD_INTERNAL
        for(u32 ShaderProgramIndex = 0; ShaderProgramIndex < ArrayCount(ShaderPrograms); ++ShaderProgramIndex)
        {
            shader_program_description *Program = ShaderPrograms + ShaderProgramIndex;
            DebugCreateShaderProgram(Program);
        }
#else
        // for the release, our shaders are stored in the same database as everything else
        // and stored in the same order as in the descriptions
        char *ShaderFileData = GlobalDatabaseBytes + KmdbHeader->ShaderDataOffset;
        for(u32 ShaderProgramIndex = 0; ShaderProgramIndex < SP_Count; ++ShaderProgramIndex)
        {
            char *VertexData = ShaderFileData;
            while(*ShaderFileData++) {}
            char *FragmentData = ShaderFileData;
            while(*ShaderFileData++) {}

            GLuint ShaderProgram = glCreateProgram();
            GLuint VertexShader = ReleaseLoadShader(VertexData, GL_VERTEX_SHADER);
            glAttachShader(ShaderProgram, VertexShader);
            GLuint FragmentShader = ReleaseLoadShader(FragmentData, GL_FRAGMENT_SHADER);
            glAttachShader(ShaderProgram, FragmentShader);
            
            glLinkProgram(ShaderProgram);
            b32 LinkSuccess = true;
            glGetProgramiv(ShaderProgram, GL_LINK_STATUS, &LinkSuccess);
            Assert(LinkSuccess);
            ShaderPrograms[ShaderProgramIndex].Handle = ShaderProgram;
            glDeleteShader(VertexShader);
            glDeleteShader(FragmentShader);
        }
#endif
        EndTiming(InitShaders);

        StartTiming(ConfiguringShaders);

        State->UsingLightTheme = Memory->ShouldUseLightTheme;
        ChangeTheme(State, State->UsingLightTheme ? LightTheme : DarkTheme);

        // the default zoom in firefox seems more like 30 px, but i like 40 better
        f32 DefaultHeightAt1Zoom = 40.f;
        State->Camera.DefaultZoom = DefaultHeightAt1Zoom / (f32)TACellSide;
        State->Camera.Zoom = State->Camera.DefaultZoom;
        State->Camera.MovesTowardsEndpoint = false;

        EndTiming(ConfiguringShaders);

        // this fixes the tilting issue
        // glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

        // NOTE on world space:
        // everything is in pixels
        // goes from -n to n in both x and y,
        // 0 is the center,
        // x goes from left to right, y - from bottom to top
        // dimensions of the camera are just window dimensions
        // camera's zoom goes from 0 to m,
        // where larger values mean that the image is more zoomed in
        //
        // We do most everything in pixel space instead, the world space is only for storage
        State->FontFile = Platform.LoadFile(Memory->FontPath, true);
        int FontOffset = stbtt_GetFontOffsetForIndex(State->FontFile.Data, 0);
        if(FontOffset == -1)
        {
            // TODO: ask user for a different font, because stb can't read this one
            eprintf("Could not parse the font file %s. Try using a different font.\n", Memory->FontPath);
            exit(1);
        }
        stbtt_InitFont(&State->Font, State->FontFile.Data, FontOffset);
        State->LargestFontScale = stbtt_ScaleForPixelHeight(&State->Font, TACellSide);
        State->UiTextScale = stbtt_ScaleForPixelHeight(&State->Font, State->Theme.UiFontPixelHeight);

        StartTiming(LoadingDatabase);

        i32 FontPathLength = 0;
        for(char *C = Memory->FontPath; *C; ++C, ++FontPathLength);

        u32 FontNameHash = MurmurHash2(Memory->FontPath, FontPathLength, 0xfeed5eed);
        State->MainLayerIndex = 0;
        State->SecondaryLayerIndex = 1;
        load_file_result ReferenceCache = Platform.LoadFile(Memory->CachePath, false);
        if(ReferenceCache.Data)
        {
            // validate the cache
            reference_cache_header *Header = (reference_cache_header *)ReferenceCache.Data;
            if((Header->Magic != REFERENCE_CACHE_MAGIC) ||
               (Header->Version != REFERENCE_CACHE_VERSION) ||
               (Header->WordCount != State->WordCount) ||
               (Header->FontNameHash != FontNameHash))
            {
                eprintf("Reference cache is invalid and needs to be recreated:\n"
                        "\t.Magic = %d (expected %d),\n"
                        "\t.Version = %d (expected %d),\n"
                        "\t.WordCount = %d (expected %d)\n"
                        "\t.FontNameHash = %d(expected %d)\n", 
                        Header->Magic, REFERENCE_CACHE_MAGIC,
                        Header->Version, REFERENCE_CACHE_VERSION,
                        Header->WordCount, State->WordCount,
                        Header->FontNameHash, FontNameHash);
                GenerateCache(State, FontNameHash, Memory);
            }
            else
            {
                State->ReferenceHeader = (reference_cache_header *)PushSize(&State->Arena, ReferenceCache.Size);
                Memcpy(State->ReferenceHeader, Header, ReferenceCache.Size);
                State->ReferenceData = (word_reference *)(State->ReferenceHeader + 1);
                Platform.UnloadFile(ReferenceCache);
            }
        }
        else
        {
            GenerateCache(State, FontNameHash, Memory);
        }
        EndTiming(LoadingDatabase);

#if DEBUG_INFO
        glEnable(GL_PROGRAM_POINT_SIZE);
        // initiallize debug queue
        glGenVertexArrays(1, &GlobalDebugQueue.VAO);
        glGenBuffers(1, &GlobalDebugQueue.VBO);
        glBindVertexArray(GlobalDebugQueue.VAO);
        {
            glBindBuffer(GL_ARRAY_BUFFER, GlobalDebugQueue.VBO);
            glBufferData(GL_ARRAY_BUFFER, sizeof(GlobalDebugQueue.Squares), 0, GL_STREAM_DRAW);

            glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(square), (GLvoid *)offsetof(square, Coordinates));
            glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(square), (GLvoid *)offsetof(square, Color));

            glEnableVertexAttribArray(0);
            glEnableVertexAttribArray(1);
        }
#endif

        // initialize line pipeline
        glGenVertexArrays(1, &State->LineVAO);
        glGenBuffers(1, &State->LineVBO);

        glBindVertexArray(State->LineVAO);
        {
            glBindBuffer(GL_ARRAY_BUFFER, State->LineVBO);
            glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(line_data), (GLvoid *)offsetof(line_data, KanjiPosition));
            glEnableVertexAttribArray(0);
            glVertexAttribDivisor(0, 1);
        }

        StartTiming(ConfiguringFonts);

        State->TA.Cells = PushStaticArray(&State->Arena, ta_cell, TACellCount);
        Memset(State->TA.Cells, 0, sizeof(ta_cell)*TACellCount);

        // texture atlas
        {
            glGenTextures(1, &State->TA.Texture);
            glBindTexture(GL_TEXTURE_2D, State->TA.Texture);
            glEnable(GL_BLEND);
            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
            glTexStorage2D(GL_TEXTURE_2D, 1, GL_R8, TASide, TASide);

            StartTiming(SettingUpGlyphs);
            // setup characters used for the interface rendering
            {
                u32 CellIndex = 0;
                for(u32 Codepoint = ' ';
                    Codepoint <= '~';
                    ++Codepoint)
                {
                    ta_cell *Cell = State->TA.Cells + CellIndex;
                    SetupGlyph(&State->Font, State->UiTextScale, &State->Arena, CellIndex, Codepoint, Cell);
                    ++CellIndex;
                }

                for(u32 Codepoint = L'ぁ';
                    Codepoint <= L'ヽ';
                    ++Codepoint)
                {
                    ta_cell *Cell = State->TA.Cells + CellIndex;
                    SetupGlyph(&State->Font, State->UiTextScale, &State->Arena, CellIndex, Codepoint, Cell);
                    ++CellIndex;
                }

                Assert(CellIndex == UiCharacterCount);
            }
            EndTiming(SettingUpGlyphs);
        }
        EndTiming(ConfiguringFonts);

        glGenVertexArrays(1, &State->TextBackgroundVAO);
        glBindVertexArray(State->TextBackgroundVAO);
        {
            glGenBuffers(1, &State->TextBackgroundVBO);
            glBindBuffer(GL_ARRAY_BUFFER, State->TextBackgroundVBO);
            glBufferData(GL_ARRAY_BUFFER, sizeof(text_background)*MaxCharactersInFrame, 0, GL_STREAM_DRAW);

            glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(text_background), (GLvoid *)offsetof(text_background, Rect.BottomLeft));
            glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(text_background), (GLvoid *)offsetof(text_background, Rect.TopRight));
            glVertexAttribPointer(2, 4, GL_FLOAT, GL_FALSE, sizeof(text_background), (GLvoid *)offsetof(text_background, Color));
            glVertexAttribPointer(3, 1, GL_FLOAT, GL_FALSE, sizeof(text_background), (GLvoid *)offsetof(text_background, Depth));

            glEnableVertexAttribArray(0);
            glEnableVertexAttribArray(1);
            glEnableVertexAttribArray(2);
            glEnableVertexAttribArray(3);

            glVertexAttribDivisor(0, 1);
            glVertexAttribDivisor(1, 1);
            glVertexAttribDivisor(2, 1);
            glVertexAttribDivisor(3, 1);
        }

        // initialize the text pipeline
        glGenVertexArrays(1, &State->TextVAO);
        glGenBuffers(1, &State->TextVBO);
        glBindVertexArray(State->TextVAO);
        {
            glBindTexture(GL_TEXTURE_2D, State->TA.Texture);
            glBindBuffer(GL_ARRAY_BUFFER, State->TextVBO);
            glBufferData(GL_ARRAY_BUFFER, sizeof(ui_text_display_data)*MaxCharactersInFrame, 0, GL_STREAM_DRAW);
            glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(ui_text_display_data), (GLvoid *)offsetof(ui_text_display_data, TextureTopLeft));
            glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(ui_text_display_data), (GLvoid *)offsetof(ui_text_display_data, TextureBottomRight));
            glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(ui_text_display_data), (GLvoid *)offsetof(ui_text_display_data, ScreenBottomLeft));
            glVertexAttribPointer(3, 2, GL_FLOAT, GL_FALSE, sizeof(ui_text_display_data), (GLvoid *)offsetof(ui_text_display_data, ScreenTopRight));
            glVertexAttribPointer(4, 4, GL_FLOAT, GL_FALSE, sizeof(ui_text_display_data), (GLvoid *)offsetof(ui_text_display_data, Color));
            glVertexAttribPointer(5, 1, GL_FLOAT, GL_FALSE, sizeof(ui_text_display_data), (GLvoid *)offsetof(ui_text_display_data, Depth));
            glEnableVertexAttribArray(0);
            glEnableVertexAttribArray(1);
            glEnableVertexAttribArray(2);
            glEnableVertexAttribArray(3);
            glEnableVertexAttribArray(4);
            glEnableVertexAttribArray(5);

            glVertexAttribDivisor(0, 1);
            glVertexAttribDivisor(1, 1);
            glVertexAttribDivisor(2, 1);
            glVertexAttribDivisor(3, 1);
            glVertexAttribDivisor(4, 1);
            glVertexAttribDivisor(5, 1);
        }

        State->ShouldShowKanjiOverlay = true;

        //
        State->Initialized = true;
        EndTiming(StateInit);
    }

    // frame start
    memory_arena *FrameArena = &State->FrameArena;
    mouse *Mouse = &Input->Mouse;
    v2 LastFrameMousePos = State->LastFrameMousePos;
    v2 MousePos = Mouse->Coordinates;

    b32 HasRightClicked = (Mouse->Buttons & MB_Right) && !(PreviousInput->Mouse.Buttons & MB_Right);
    b32 HasMiddleClicked = (Mouse->Buttons & MB_Middle) && !(PreviousInput->Mouse.Buttons & MB_Middle);

    b32 BookmarksChanged = false;

    if(State->Camera.Dim.x != WindowDim.x ||
       State->Camera.Dim.y != WindowDim.y)
    {
        State->Camera.Dim = WindowDim;
        glViewport(0, 0, WindowDim.x, WindowDim.y);
    }

    f32 dTime = Input->Time - State->LastFrameTime;

    if(Input->PressedKeys & Key_ZoomReset)
    {
        State->Camera.Zoom = State->Camera.DefaultZoom;
    }

    if(Input->PressedKeys & Key_ZoomIn)
    {
        ZoomIn(&State->Camera, LastFrameMousePos, dTime, Input->Time);
    }

    if(Input->PressedKeys & Key_ZoomOut)
    {
        ZoomOut(&State->Camera, dTime, Input->Time);
    }

#define PressedNotHeld(Key) ((Input->PressedKeys & (Key)) && !(PreviousInput->PressedKeys & (Key)))

    if(PressedNotHeld(Key_ToggleBookmarkView))
    {
        reference_layer *OldLayer = State->ReferenceHeader->Layers + State->MainLayerIndex;
        reference_layer *NewLayer = State->ReferenceHeader->Layers + State->SecondaryLayerIndex;
        State->SelectedCodepoint = 0;
        OldLayer->CameraPos = State->Camera.Pos;
        State->Camera.Pos = NewLayer->CameraPos;
        Swap(State->MainLayerIndex, State->SecondaryLayerIndex);
    }

    if(PressedNotHeld(Key_ToggleKanjiOverlay))
    {
        State->ShouldShowKanjiOverlay = !State->ShouldShowKanjiOverlay;
    }

    // move the camera
    camera *Camera = &State->Camera;
    if(Camera->MovesTowardsEndpoint)
    {
        f32 t = (Input->Time - Camera->MovementStartTime) / Camera->MovementTime;
        Camera->Pos = V2Lerp(Camera->Startpoint, Camera->Endpoint, t);
        Camera->Zoom = Lerp(Camera->ZoomOrigin, Camera->ZoomTarget, t);
        if(t >= 1.f)
        {
            Camera->MovesTowardsEndpoint = false;
            Camera->Pos = Camera->Endpoint;
            Camera->Zoom = Camera->ZoomTarget;
        }
    }
    else if((Mouse->Buttons & MB_Left) && !(Mouse->Buttons & MB_Right))
    {
        v2 dCamera = V2Sub(LastFrameMousePos, MousePos);
        Camera->Pos = V2Add(Camera->Pos, V2TimesScalar(dCamera, 1.f / Camera->Zoom));
    }

    if(PressedNotHeld(Key_Paste) && Input->Clipboard)
    {
        State->InputField = ConvertToCodepoints(Input->Clipboard);
        State->InputFieldCursorPosition = State->InputField.Count;
    }
    else if(Input->CodepointBuffer.Count)
    {
        Assert(State->InputField.Count + Input->CodepointBuffer.Count < ArrayCount(State->InputField.Data));
        // ab|c (2) (d) -> abd|c
        Memcpy(State->InputField.Data + State->InputFieldCursorPosition + Input->CodepointBuffer.Count,
               State->InputField.Data + State->InputFieldCursorPosition,
               sizeof(c32)*Input->CodepointBuffer.Count);
        Memcpy(State->InputField.Data + State->InputFieldCursorPosition,
               Input->CodepointBuffer.Data,
               sizeof(c32)*Input->CodepointBuffer.Count);

        State->InputField.Count += Input->CodepointBuffer.Count;
        State->InputFieldCursorPosition += Input->CodepointBuffer.Count;
    }
    else if(State->InputField.Count)
    {
        if(PressedNotHeld(Key_CursorLeft))
        {
            State->InputFieldCursorPosition = (u32)Maximum(0, (i32)State->InputFieldCursorPosition - 1);
        }
        else if(PressedNotHeld(Key_CursorRight))
        {
            State->InputFieldCursorPosition = Minimum(State->InputField.Count, State->InputFieldCursorPosition + 1);
        }
        else if(PressedNotHeld(Key_Backspace))
        {
            // ab|c (2) -> a|c
            // |ac  (0) -> |ac
            // ac|  (2) -> a|
            if(State->InputFieldCursorPosition)
            {
                if(State->InputFieldCursorPosition < State->InputField.Count)
                {
                    Memcpy(State->InputField.Data + State->InputFieldCursorPosition - 1,
                           State->InputField.Data + State->InputFieldCursorPosition,
                           sizeof(c32)*(State->InputField.Count - State->InputFieldCursorPosition));
                }
                State->InputField.Count--;
                State->InputFieldCursorPosition = (u32)Maximum(0, (i32)State->InputFieldCursorPosition - 1);
            }
        }
        else if(PressedNotHeld(Key_Delete))
        {
            // ab|cde (2) -> ab|de
            if(State->InputFieldCursorPosition < State->InputField.Count)
            {
                if(State->InputFieldCursorPosition < (State->InputField.Count - 1))
                {
                    Memcpy(State->InputField.Data + State->InputFieldCursorPosition,
                           State->InputField.Data + State->InputFieldCursorPosition + 1,
                           sizeof(c32)*(State->InputField.Count - State->InputFieldCursorPosition));
                }
                State->InputField.Count--;
                State->InputFieldCursorPosition = Minimum(State->InputFieldCursorPosition, State->InputField.Count);
            }
        }
    }

    if(State->SearchResultCount)
    {
        if(PressedNotHeld(Key_NextWordInSearch))
        {
            u32 NewSearchResultPos = (State->SearchResultPos + 1) == State->SearchResultCount ? 0 : State->SearchResultPos + 1;
            State->SearchResultPos = NewSearchResultPos;
            u32 NewSelectedWordIndex = State->SearchResultIndices[NewSearchResultPos];
            SelectWord(State, NewSelectedWordIndex, Input->Time, FrameArena);
        }
        if(PressedNotHeld(Key_PreviousWordInSearch))
        {
            u32 NewSearchResultPos = (State->SearchResultPos == 0) ? State->SearchResultCount - 1 : State->SearchResultPos - 1;
            State->SearchResultPos = NewSearchResultPos;
            u32 NewSelectedWordIndex = State->SearchResultIndices[NewSearchResultPos];
            SelectWord(State, NewSelectedWordIndex, Input->Time, FrameArena);
        }
    }

    // NOTE: by this point, camera has been set up
    visible_word_indices VisibleWords = GetVisibleWords(State);
    for(u32 ShaderProgrami = 0; ShaderProgrami < ArrayCount(ShaderPrograms); ++ShaderProgrami)
    {
        GLuint Program = ShaderPrograms[ShaderProgrami].Handle;
        glUseProgram(Program);
        glUniform2f(glGetUniformLocation(Program, "CameraPos"), State->Camera.Pos.x, State->Camera.Pos.y);
        glUniform2f(glGetUniformLocation(Program, "CameraDim"), State->Camera.Dim.x, State->Camera.Dim.y);
        glUniform1f(glGetUniformLocation(Program, "CameraZoom"), State->Camera.Zoom);
        glUniform1f(glGetUniformLocation(Program, "CameraDefaultZoom"), State->Camera.DefaultZoom);
    }

    if(PressedNotHeld(Key_Search) && (State->InputField.Count > 0))
    {
        // NOTE: first, determine what kind of text user wants to search:
        // if it consists of kanji and kana, search in writings,
        // if it only consists of kana, search in writings and readings,
        // and if it's neither, convert it to kana to search in readings, and search in meanings.
        //
        // For readings and meanings, it's probably OK to (for now) only do exact search 
        // since it's pretty slow the way we do it
        ResetArena(&State->SearchArena);
        State->SearchResultCount = 0;
        State->SearchResultPos = 0;
        State->SearchResultIndices = (u32 *)State->SearchArena.Base;
        Assert(alignof(State->SearchResultIndices) >= 4);

        b32 InputHasKanji = false,
            InputHasKana = false;
        for(u32 CharacterIndex = 0; CharacterIndex < State->InputField.Count; ++CharacterIndex)
        {
            c32 InputCharacter = State->InputField.Data[CharacterIndex];
            if(IsKanji(InputCharacter))
            {
                InputHasKanji = true;
            }
            else if(IsKana(InputCharacter))
            {
                InputHasKana = true;
            }
        }

        // perform the search proper
        if(InputHasKanji)
        {
            u32 LongestCommonSequenceLength = 0;

            for(u32 InputCodepointIndex = 0; InputCodepointIndex < State->InputField.Count; ++InputCodepointIndex)
            {
                c32 InputCodepoint = State->InputField.Data[InputCodepointIndex];
                if(IsKanji(InputCodepoint))
                {
                    kanji_data CodepointData = GetKanjiData(&State->KanjiHashtable, InputCodepoint);

                    for(u32 MatchIndex = 0; MatchIndex < CodepointData.WordCount; ++MatchIndex)
                    {
                        u32 SelectedWordIndex = CodepointData.WordIndices[MatchIndex];
                        word *SelectedWord = State->Words + SelectedWordIndex;
                        codepoints SelectedCodepoints =
                            ConvertToCodepoints(SelectedWord->Writing);
                        u32 ThisWordMaxSequenceLength = 0, CurrentSequenceLength = 0;
                        for(u32 S1Index = 0;
                            (S1Index + CurrentSequenceLength) < State->InputField.Count;
                            ++S1Index)
                        {
                            for(u32 S2Index = CurrentSequenceLength;
                                S2Index < SelectedCodepoints.Count;
                                ++S2Index)
                            {
                                if(State->InputField.Data[S1Index + CurrentSequenceLength] == SelectedCodepoints.Data[S2Index])
                                {
                                    ++CurrentSequenceLength;
                                }
                                else
                                {
                                    ThisWordMaxSequenceLength = Maximum(ThisWordMaxSequenceLength, CurrentSequenceLength);
                                    CurrentSequenceLength = 0;
                                }
                            }
                        }

                        ThisWordMaxSequenceLength = Maximum(ThisWordMaxSequenceLength, CurrentSequenceLength);

                        if(ThisWordMaxSequenceLength == State->InputField.Count)
                        {
                            State->SearchResultIndices[State->SearchResultCount++] = SelectedWordIndex;
                            // exact match
                            if(ThisWordMaxSequenceLength == SelectedCodepoints.Count)
                            {
                                State->SearchResultPos = State->SearchResultCount - 1;
                                SelectWord(State, SelectedWordIndex, Input->Time, FrameArena);
                            }
                        }
                    }
                }
            }
        }
        else
        {
            search_result SearchResult;
            if(InputHasKana)
            {
                char ReadingQuery[256] = {0};
                size_t ReadingQueryLength = EncodeCodepointsToUtf8(State->InputField, ReadingQuery, sizeof(ReadingQuery));
                SearchResult = SearchAndSelectClosestMatch(State, ReadingQueryLength, ReadingQuery, SF_Readings, FrameArena, Input->Time);
            }
            else
            {
                conversion_result Hiragana = ConvertToHiragana(State->InputField);
                if(Hiragana.IsValid)
                {
                    char ReadingQuery[256] = {0};
                    size_t ReadingQueryLength = EncodeCodepointsToUtf8(Hiragana.Value, ReadingQuery, sizeof(ReadingQuery));
                    SearchResult = SearchAndSelectClosestMatch(State, ReadingQueryLength, ReadingQuery, SF_Readings, FrameArena, Input->Time);
                    if(SearchResult.MatchCount == 0)
                    {
                        goto SearchMeanings;
                    }
                }
                else
                {
SearchMeanings:
                    char MeaningQuery[256] = {0};
                    size_t MeaningQueryLength = EncodeCodepointsToUtf8(State->InputField, MeaningQuery, sizeof(MeaningQuery));
                    SearchResult = SearchAndSelectClosestMatch(State, MeaningQueryLength, MeaningQuery, SF_Meanings, FrameArena, Input->Time);
                }
            }

            if(SearchResult.MatchCount)
            {
                State->SearchResultCount = SearchResult.MatchCount;
                Memcpy(State->SearchResultIndices, SearchResult.Indices, sizeof(u32)*State->SearchResultCount);
            }
        }
    }
    Assert((State->SearchResultPos == 0 && State->SearchResultCount == 0) ||
           (State->SearchResultPos < State->SearchResultCount));

    StartTiming(PrepMainPass);

    v4 *Colors = State->Theme.Colors;

    text_render_queue RenderQueue =
    {
        .MaxCharacterCount = MaxCharactersInFrame,
        .MaxBackgroundCount = MaxCharactersInFrame,
        .CharacterCount = 0,
        .BackgroundCount = 0,
        .Characters = PushStaticArray(FrameArena, ui_text_display_data, MaxCharactersInFrame),
        .Backgrounds = PushStaticArray(FrameArena, text_background, MaxCharactersInFrame)
    };

    rect WindowRect =
        RectangleFromCenterAndDim(V2(State->Camera.Pos.x, State->Camera.Pos.y),
                                  V2TimesScalar(WindowDim, (1.f / State->Camera.Zoom)));

    // TODO: do we want the ability to deselect?

    f32 KanjiPixelHeight = State->Camera.Zoom / State->Camera.DefaultZoom * 40.f;
    f32 KanjiFontScale = stbtt_ScaleForPixelHeight(&State->Font, KanjiPixelHeight);

    u32 HoveredWordIndex = UINT32_MAX;
    rect HoveredBoundingBox;
    for(u32 VisibleWordIndex = 0; VisibleWordIndex < VisibleWords.Count; ++VisibleWordIndex)
    {
        StartTiming(PushingKanjiAndBackgrounds);
        u32 WordIndex = VisibleWords.Indices[VisibleWordIndex];
        word *Word = State->Words + WordIndex;
        rect BoundingBox = GetWordBoundingBox(State, WordIndex);

        codepoints WritingCodepoints = ConvertToCodepoints(Word->Writing);

        if(RectanglesIntersect(BoundingBox, WindowRect))
        {
            StartTiming(IfWordInWindow);
            v4 WritingColors[WritingCodepoints.Count];
            v4 InactiveButtonColor = Colors[CT_Background];
            v4 ActiveButtonColor = Colors[CT_Text];

            for(u32 CodepointIndex = 0; CodepointIndex < WritingCodepoints.Count; ++CodepointIndex)
            {
                if(WritingCodepoints.Data[CodepointIndex] == State->SelectedCodepoint)
                {
                    WritingColors[CodepointIndex] = Colors[CT_Highlight];
                    InactiveButtonColor = Colors[CT_Highlight];
                }
                else
                {
                    WritingColors[CodepointIndex] = Colors[CT_Text];
                }
            }

            rect PixelSpaceBoundingBox = PushMulticoloredLine(State, &RenderQueue, WorldToPixelSpace(BoundingBox.BottomLeft, State->Camera), KanjiFontScale, WritingCodepoints.Count, WritingCodepoints.Data, WritingColors);

            if(CheckButton(PixelSpaceBoundingBox, ActiveButtonColor, InactiveButtonColor))
            {
                HoveredWordIndex = WordIndex;
                HoveredBoundingBox = PixelSpaceBoundingBox;
                f32 BarycentricX = (MousePos.x - PixelSpaceBoundingBox.BottomLeft.x) / (PixelSpaceBoundingBox.TopRight.x - PixelSpaceBoundingBox.BottomLeft.x);
                BarycentricX = Clamp(BarycentricX, 0.0f, 0.99f);
                u32 SelectedKanjiIndex = (u32)(BarycentricX * WritingCodepoints.Count);

                Assert(SelectedKanjiIndex < WritingCodepoints.Count);

                c32 SelectedCodepoint = WritingCodepoints.Data[SelectedKanjiIndex];
                if(HasRightClicked && (!Camera->MovesTowardsEndpoint))
                {
                    if(IsKanji(SelectedCodepoint))
                    {
                        SelectKanjiAndDrawLines(State, WordIndex, SelectedCodepoint);
                    }
                    if(Mouse->Buttons & MB_Left)
                    {
                        MoveCameraToWord(State, WordIndex, Input->Time);
                    }
                }
                if(HasMiddleClicked && (!State->MainLayerIndex) && (!Camera->MovesTowardsEndpoint))
                {
                    reference_layer *Layer = State->ReferenceHeader->Layers + State->SecondaryLayerIndex;
                    rect BoundingBox = GetWordBoundingBox(State, WordIndex);
                    b32 ReferenceExists = false;
                    word_reference *FirstReference = State->ReferenceData + (State->SecondaryLayerIndex * State->WordCount);
                    for(u32 ReferenceIndex = 0; ReferenceIndex < Layer->ReferenceCount; ++ReferenceIndex)
                    {
                        word_reference *Reference = FirstReference + ReferenceIndex;
                        if(Reference->WordIndex == WordIndex)
                        {
                            ReferenceExists = true;
                            break;
                        }
                    }
                    if(!ReferenceExists)
                    {
                        // bookmark the word and update the bookmark file
                        u32 ReferenceIndex = Layer->ReferenceCount++;
                        u32 ChunkIndex = ReferenceIndex / WordsPerChunk;
                        word_reference *Reference = FirstReference + ReferenceIndex;

                        u32 ChunkRelativeIndex = ReferenceIndex % WordsPerChunk;
                        u32 MaxChunkCount = State->WordCount / WordsPerChunk;
                        i32 MaxChunkTotalRows = (i32)Sqrt((f32)MaxChunkCount);
                        rect OtherWordsInChunk[WordsPerChunk];
                        for(u32 OtherWordIndex = 0; OtherWordIndex < ChunkRelativeIndex; ++OtherWordIndex)
                        {
                            OtherWordsInChunk[OtherWordIndex] = State->ReferenceData[(WordsPerChunk*ChunkIndex) + OtherWordIndex].BoundingBox;
                        }
                        rect WorldBoundingBox = GetWordBoundingBox(State, WordIndex);
                        rect BoundingBox = GetNewWordBoundingBox(&Layer->Rng, MaxChunkTotalRows, ChunkIndex, RectangleGetDim(WorldBoundingBox), ChunkRelativeIndex, OtherWordsInChunk);
                        Reference->BoundingBox = BoundingBox;
                        Reference->WordIndex = WordIndex;
                        Layer->CameraPos = RectangleGetCenter(BoundingBox);
                    }
                    BookmarksChanged = true;
                }
            }

            EndTiming(IfWordInWindow);
        }
        EndTiming(PushingKanjiAndBackgrounds);
    }

    EndTiming(PrepMainPass);

    StartTiming(Rendering);

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    // render the background
    UseShader(SP_Background);
    glUniform1f(glGetUniformLocation(ShaderPrograms[SP_Background].Handle, "Time"), Input->Time);
    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

    // by this point, we have checked all the places where the codepoint could have been selected
    kanji_data SelectedCodepointData = GetKanjiData(&State->KanjiHashtable, State->SelectedCodepoint);
    if(State->SelectedCodepoint)
    {
        StartTiming(MovingCameraAndDrawingLines);

        u32 OldPosition = State->SelectedWordPosition;
        if(PressedNotHeld(Key_NextSimilarWord))
        {
            if((++State->SelectedWordPosition) == State->LineCount)
            {
                State->SelectedWordPosition = 0;
            }
        }
        else if(PressedNotHeld(Key_PreviousSimilarWord))
        {
            if(State->SelectedWordPosition == 0)
            {
                State->SelectedWordPosition = State->LineCount - 1;
            }
            else
            {
                State->SelectedWordPosition--;
            }
        }

        if(State->SelectedWordPosition != OldPosition)
        {
            line_data *Line = State->Lines + State->SelectedWordPosition;
            ChangeLineCenter(Line->KanjiPosition);
            TransitionCamera(&State->Camera, Line->KanjiPosition, State->Camera.Zoom, Input->Time);
        }

        EndTiming(MovingCameraAndDrawingLines);

        StartTiming(LinePass);

        UseShader(SP_Lines);
        glBindVertexArray(State->LineVAO);
        glBindBuffer(GL_ARRAY_BUFFER, State->LineVBO);
        glDrawArraysInstanced(GL_TRIANGLE_STRIP, 0, 4, State->LineCount);
        EndTiming(LinePass);
    }

    int Ascent, Descent, LineGap;
    stbtt_GetFontVMetrics(&State->Font, &Ascent, &Descent, &LineGap);

    f32 UiLineHeight = State->UiTextScale * (Ascent - Descent + LineGap);

    f32 KanjiUiHeight = 0.f;

    // NOTE: currently the background borders are drawn in addition to given dimensions
    if(State->SelectedCodepoint)
    {
        // this reason we draw word info in both branches is that it needs to be behind other stuff
        if(State->ShouldShowKanjiOverlay)
        {
            StartTiming(DrawingKanjiOverlay);

            u32 SimilarKanjiPerLine = 10;
            f32 BigKanjiTextSize = 100.f;
            f32 BigKanjiScale = stbtt_ScaleForPixelHeight(&State->Font, BigKanjiTextSize);

            v2 BigKanjiDim;
            {
                int X0, X1, Y0, Y1;
                stbtt_GetGlyphBitmapBox(&State->Font, State->SelectedCodepoint, BigKanjiScale, BigKanjiScale, &X0, &Y0, &X1, &Y1);
                BigKanjiDim.x = X1 - X0;
                BigKanjiDim.y = Y1 - Y0;
            }

            u32 MultilineFields[] =
            {
                SelectedCodepointData.OnReadingCount,
                SelectedCodepointData.KunReadingCount,
                SelectedCodepointData.MeaningCount,
                SelectedCodepointData.SimilarKanjiCount / SimilarKanjiPerLine,
                SelectedCodepointData.RadicalCount,
                SelectedCodepointData.FrequentlyUsedWordCount
            };

            u32 MostNewlinesInField = 0;
            for(u32 FieldIndex = 0; FieldIndex < ArrayCount(MultilineFields); ++FieldIndex)
            {
                MostNewlinesInField = Maximum(MostNewlinesInField, MultilineFields[FieldIndex]);
            }

            f32 TextHeight = Maximum(UiLineHeight*MostNewlinesInField, BigKanjiDim.y);

            v2 TextPadding = V2(25.f, 25.f);
            KanjiUiHeight = TextHeight + 2.f * TextPadding.y;
            //KanjiUiHeight += State->Theme.UiBorderWidth;

            v2 BigKanjiBottomLeft = V2(25.f, (KanjiUiHeight - BigKanjiDim.y + State->Theme.UiBorderWidth) * .5f);
            PushSingleColoredLine(State, &RenderQueue, BigKanjiBottomLeft, BigKanjiScale, 1, &State->SelectedCodepoint, Colors[CT_Text]);

            v2 FirstColumnTop = V2(BigKanjiBottomLeft.x*2.f + BigKanjiDim.x,
                                   KanjiUiHeight - TextPadding.y);

            rect KanjiUIRect = 
            {
                .BottomLeft = V2(0, 0),
                .TopRight = V2(State->Camera.Dim.x, KanjiUiHeight)
            };
            PushBackground(&RenderQueue, KanjiUIRect, Colors[CT_Highlight]); // TODO: replicate button that blocks everything below it

            DrawSelectedWordInfo(State, &RenderQueue, UiLineHeight, KanjiUiHeight);

            text_printer Printer = TextPrinter(State, &RenderQueue, FirstColumnTop, UiLineHeight, State->UiTextScale, -1, -1);

            if(SelectedCodepointData.MeaningCount)
            {
                PrintText(&Printer, "Meaning", Colors[CT_Highlight]);
                PrintNewline(&Printer);
                char *Meaning = SelectedCodepointData.Meanings;
                for(u32 MeaningIndex = 0; MeaningIndex < SelectedCodepointData.MeaningCount; ++MeaningIndex)
                {
                    PrintText(&Printer, Meaning, Colors[CT_Text]);
                    while(*Meaning)
                    {
                        ++Meaning;
                    }
                    ++Meaning;
                    PrintNewline(&Printer);
                }

                SetPrinterPos(&Printer, V2(Printer.BoundingBox.TopRight.x + TextPadding.x, FirstColumnTop.y));
            }

            if(SelectedCodepointData.OnReadingCount)
            {
                PrintText(&Printer, "音", Colors[CT_Highlight]);
                PrintNewline(&Printer);
                char *OnReading = SelectedCodepointData.OnReadings;
                for(u32 OnReadingIndex = 0; OnReadingIndex < SelectedCodepointData.OnReadingCount; ++OnReadingIndex)
                {
                    PrintText(&Printer, OnReading, Colors[CT_Text]);
                    while(*OnReading)
                    {
                        ++OnReading;
                    }
                    ++OnReading;
                    PrintNewline(&Printer);
                }

                SetPrinterPos(&Printer, V2(Printer.BoundingBox.TopRight.x + TextPadding.x, FirstColumnTop.y));
            }

            if(SelectedCodepointData.KunReadingCount)
            {
                PrintText(&Printer, "訓", Colors[CT_Highlight]);
                PrintNewline(&Printer);
                char *KunReading = SelectedCodepointData.KunReadings;
                for(u32 KunReadingIndex = 0; KunReadingIndex < SelectedCodepointData.KunReadingCount; ++KunReadingIndex)
                {
                    PrintText(&Printer, KunReading, Colors[CT_Text]);
                    while(*KunReading)
                    {
                        ++KunReading;
                    }
                    ++KunReading;
                    PrintNewline(&Printer);
                }
                SetPrinterPos(&Printer, V2(Printer.BoundingBox.TopRight.x + TextPadding.x, FirstColumnTop.y));
            }

            if(SelectedCodepointData.RadicalCount)
            {
                PrintText(&Printer, "Elements", Colors[CT_Highlight]);
                PrintNewline(&Printer);
                for(u32 RadicalIndex = 0; RadicalIndex < SelectedCodepointData.RadicalCount; ++RadicalIndex)
                {
                    c32 Radical = SelectedCodepointData.Radicals[RadicalIndex];
                    PrintCodepoints(&Printer, 1, &Radical, Colors[CT_Text]);
                    kanji_data RadicalData = GetKanjiData(&State->KanjiHashtable, Radical);
                    if(RadicalData.MeaningCount)
                    {
                        PrintText(&Printer, " (", Colors[CT_Text]);
                        PrintText(&Printer, RadicalData.Meanings, Colors[CT_Text]);
                        PrintText(&Printer, ")", Colors[CT_Text]);
                    }
                    PrintNewline(&Printer);
                }
                SetPrinterPos(&Printer, V2(Printer.BoundingBox.TopRight.x + TextPadding.x, FirstColumnTop.y));
            }

            if(SelectedCodepointData.SimilarKanjiCount)
            {
                PrintText(&Printer, "Similar kanji", Colors[CT_Highlight]);
                PrintNewline(&Printer);
                for(u32 SimilarKanjiIndex = 0; SimilarKanjiIndex < SelectedCodepointData.SimilarKanjiCount; ++SimilarKanjiIndex)
                {
                    c32 SimilarKanji = SelectedCodepointData.SimilarKanji[SimilarKanjiIndex];
                    rect SimilarKanjiRect = PrintCodepoints(&Printer, 1, &SimilarKanji, Colors[CT_Text]);
                    PrintText(&Printer, " ", Colors[CT_Text]);
                    if(((SimilarKanjiIndex + 1) % (SimilarKanjiPerLine + 1)) == 0)
                    {
                        PrintNewline(&Printer);
                    }

                    if(CheckButton(SimilarKanjiRect))
                    {
                        if(HasRightClicked)
                        {
                            u32 WordIndex = GetKanjiData(&State->KanjiHashtable, SimilarKanji).WordIndices[0];
                            SelectKanjiAndDrawLines(State, WordIndex, SimilarKanji);
                            MoveCameraToWord(State, WordIndex, Input->Time);
                        }
                    }
                }
                SetPrinterPos(&Printer, V2(Printer.BoundingBox.TopRight.x + TextPadding.x, FirstColumnTop.y));
            }

            if(SelectedCodepointData.FrequentlyUsedWordCount)
            {
                PrintText(&Printer, "Frequently used words", Colors[CT_Highlight]);
                PrintNewline(&Printer);
                for(u32 FrequentlyUsedWordIndex = 0; FrequentlyUsedWordIndex < SelectedCodepointData.FrequentlyUsedWordCount; ++FrequentlyUsedWordIndex)
                {
                    u32 WordIndex = SelectedCodepointData.FrequentlyUsedWordIndices[FrequentlyUsedWordIndex];
                    word *Word = State->Words + WordIndex;
                    rect WordButton = PrintText(&Printer, Word->Writing, Colors[CT_Text]);
                    PrintNewline(&Printer);

                    if(CheckButton(WordButton))
                    {
                        if(HasRightClicked)
                        {
                            SelectKanjiAndDrawLines(State, WordIndex, State->SelectedCodepoint);
                            MoveCameraToWord(State, WordIndex, Input->Time);
                        }
                        DrawWordDictionaryInfo(State, &RenderQueue, UiLineHeight, KanjiUiHeight, WordIndex, WordButton);
                    }
                }
                //SetPrinterPos(&Printer, V2(Printer.BoundingBox.TopRight.x + TextPadding.x, FirstColumnTop.y));
            }

            EndTiming(DrawingKanjiOverlay);
        }
        else
        {
            DrawSelectedWordInfo(State, &RenderQueue, UiLineHeight, 0.f);
        }
    }

    if((HoveredWordIndex != UINT32_MAX) &&
       (MousePos.y > KanjiUiHeight) &&
       (!State->Lines || (HoveredWordIndex != State->Lines[State->SelectedWordPosition].WordIndex)))
    {
        DrawWordDictionaryInfo(State, &RenderQueue, UiLineHeight, KanjiUiHeight, HoveredWordIndex, HoveredBoundingBox);
    }


    b32 ScrollingActivated = false;
    // these back and forth conversions are just ugly
    if(State->InputField.Count)
    {
        StartTiming(DrawingSearchField);
        StartTiming(DrawingInputArea);
        // here we need to add the rest of the buttons before adding the bottom-most one, so this is awkward
        v2 InputFieldPos = V2(State->Theme.UiBorderWidth, State->Camera.Dim.y - UiLineHeight);
        text_printer Printer = TextPrinter(State, &RenderQueue, InputFieldPos, UiLineHeight, State->UiTextScale, -1, -1);
        PrintText(&Printer, "Search: ", Colors[CT_Text]);

        PrintCodepoints(&Printer, State->InputFieldCursorPosition, State->InputField.Data, Colors[CT_Text]);
        v2 TopLeft = V2(Printer.BoundingBox.TopRight.x, InputFieldPos.y);
        PrintText(&Printer, "|", Colors[CT_Text]);

        u32 AfterCursorCharacterCount = State->InputField.Count - State->InputFieldCursorPosition;
        if(AfterCursorCharacterCount)
        {
            SetPrinterPos(&Printer, TopLeft);
            PrintCodepoints(&Printer, AfterCursorCharacterCount, State->InputField.Data + State->InputFieldCursorPosition, Colors[CT_Text]);
        }

        conversion_result Hiragana = ConvertToHiragana(State->InputField);
        if(Hiragana.IsValid)
        {
            PrintText(&Printer, " (", Colors[CT_Text]);
            PrintCodepoints(&Printer, Hiragana.Value.Count, Hiragana.Value.Data, Colors[CT_Text]);
            PrintText(&Printer, ")", Colors[CT_Text]);
        }
        EndTiming(DrawingInputArea);
        if(State->SearchResultCount)
        {
            StartTiming(DrawingSearchResults);

            SetPrinterPos(&Printer, V2(InputFieldPos.x, InputFieldPos.y - UiLineHeight));
            PrintText(&Printer, "(", Colors[CT_Text]);
            codepoints SearchCodepoints = U32ToCodepoints(State->SearchResultCount);
            PrintCodepoints(&Printer, SearchCodepoints.Count, SearchCodepoints.Data, Colors[CT_Text]);
            PrintText(&Printer, State->SearchResultCount == 1 ? " result found)" : " results found)", Colors[CT_Text]);
            //PrintNewline(&Printer);

            // draw the search results
            {
                u32 MaxResultsOnScreen = 10;
                u32 FirstResultPos = 0;
                u32 ResultCount = MaxResultsOnScreen;
                if(State->SearchResultPos > (MaxResultsOnScreen - 1))
                {
                    FirstResultPos = State->SearchResultPos - MaxResultsOnScreen + 1;
                }
                else
                {
                    ResultCount = Minimum(MaxResultsOnScreen, State->SearchResultCount);
                }
                u32 LongestLineLength = 0;
                for(u32 ResultIndex = 0; ResultIndex < ResultCount; ++ResultIndex)
                {
                    u32 WordIndex = State->SearchResultIndices[FirstResultPos + ResultIndex];
                    word *SearchResult = State->Words + WordIndex;
                    codepoints FirstReading = ConvertToCodepoints(SearchResult->Readings);
                    LongestLineLength = Maximum(LongestLineLength, FirstReading.Count);
                }

                for(u32 ResultIndex = 0; ResultIndex < ResultCount; ++ResultIndex)
                {
                    PrintNewline(&Printer);
                    u32 ResultPos = FirstResultPos + ResultIndex;
                    u32 WordIndex = State->SearchResultIndices[ResultPos];
                    word *SearchResult = State->Words + WordIndex;
                    rect BoundingBox = PrintText(&Printer, SearchResult->Writing, (ResultPos == State->SearchResultPos) ? Colors[CT_Highlight] : Colors[CT_Text]);
                    if(CheckButton(BoundingBox))
                    {
                        if(HasRightClicked)
                        {
                            u32 NewSelectedSearchResultIndex = ResultPos;
                            Assert(NewSelectedSearchResultIndex < State->SearchResultCount);
                            State->SearchResultPos = NewSelectedSearchResultIndex;
                            SelectWord(State, State->SearchResultIndices[NewSelectedSearchResultIndex], Input->Time, FrameArena);
                        }
                    }
                }
            }

            if(State->SearchResultCount)
            {
                if(CheckButton(Printer.BoundingBox))
                {
                    ScrollingActivated = !!(Input->Mouse.Scroll);
                    f32 Scroll = Input->Mouse.Scroll;
                    if(Scroll)
                    {
                        if(Scroll < 0.f)
                        {
                            State->SearchResultPos = (State->SearchResultPos + 1) == State->SearchResultCount ? 0 : State->SearchResultPos + 1;
                        }
                        else
                        {
                            State->SearchResultPos = (State->SearchResultPos == 0) ? State->SearchResultCount - 1 : State->SearchResultPos - 1;
                        }
                        SelectWord(State, State->SearchResultIndices[State->SearchResultPos], Input->Time, &State->FrameArena);
                    }
                }
            }
            EndTiming(DrawingSearchResults);
        }
        PushBackground(&RenderQueue, Printer.BoundingBox, Colors[CT_Background]);
        EndTiming(DrawingSearchField);
    }

    // print active reference layer
    {
        v2 PrinterPos = V2(State->Camera.Dim.x - UiLineHeight, State->Camera.Dim.y - UiLineHeight);
        text_printer Printer = TextPrinter(State, &RenderQueue, PrinterPos, UiLineHeight, State->UiTextScale, -1, -1);
        rect BoundingBoxes[ReferenceLayerCount] = {0};
        for(u32 LayerIndex = 0; LayerIndex < ReferenceLayerCount; ++LayerIndex)
        {
            c32 PrintableLayerIndex = LayerIndex + '0';
            BoundingBoxes[LayerIndex] = PrintCodepoints(&Printer, 1, &PrintableLayerIndex, State->MainLayerIndex == LayerIndex ? Colors[CT_Highlight] : Colors[CT_Text]);
            PrintNewline(&Printer);
        }

        PushBackground(&RenderQueue, Printer.BoundingBox, Colors[CT_Background]);

        for(u32 LayerIndex = 0; LayerIndex < ReferenceLayerCount; ++LayerIndex)
        {
            if(CheckButton(BoundingBoxes[LayerIndex]))
            {
                if(HasRightClicked)
                {
                    u32 NewMainLayerIndex = LayerIndex;
                    Assert(NewMainLayerIndex < ReferenceLayerCount);

                    reference_layer *OldLayer = State->ReferenceHeader->Layers + State->MainLayerIndex;
                    reference_layer *NewLayer = State->ReferenceHeader->Layers + NewMainLayerIndex;

                    State->SelectedCodepoint = 0;

                    OldLayer->CameraPos = State->Camera.Pos;
                    State->Camera.Pos = NewLayer->CameraPos;

                    State->SecondaryLayerIndex = State->MainLayerIndex;
                    State->MainLayerIndex = NewMainLayerIndex;
                }
                if(HasMiddleClicked)
                {
                    u32 NewSecondaryLayer = LayerIndex;
                    Assert(NewSecondaryLayer < ReferenceLayerCount);
                    State->SecondaryLayerIndex = NewSecondaryLayer;
                }
            }
        }
    }

    // draw light mode indicator
    {
        codepoints Mode = ConvertToCodepoints(State->UsingLightTheme ? "light mode" : "dark mode");
        v2 IndicatorBottomLeft = V2(State->Camera.Dim.x - (6.f * UiLineHeight), State->Camera.Dim.y - UiLineHeight);
        rect ModeBoundingBox = PushSingleColoredLine(State, &RenderQueue, IndicatorBottomLeft, State->UiTextScale, Mode.Count, Mode.Data, Colors[CT_Text]);
        if(CheckButton(ModeBoundingBox, Colors[CT_Background]))
        {
            if(HasRightClicked)
            {
                if(State->UsingLightTheme)
                {
                    ChangeTheme(State, DarkTheme);
                }
                else
                {
                    ChangeTheme(State, LightTheme);
                }
                State->UsingLightTheme = !State->UsingLightTheme;
            }
        }
    }

    StartTiming(DrawingButtons);

    if(!ScrollingActivated)
    {
        if(Input->Mouse.Scroll > 0.f)
        {
            ZoomIn(&State->Camera, LastFrameMousePos, dTime, Input->Time);
        }
        if(Input->Mouse.Scroll < 0.f)
        {
            ZoomOut(&State->Camera, dTime, Input->Time);
        }
    }

    EndTiming(DrawingButtons);

#if DEBUG_INFO
    // debug pass
    StartTiming(DebugPass);

    u32 TimingCount = GlobalDebugTimingCount;

#if 0
    f32 TimeForFrame = .0166f;
    StartTiming(DrawingDebugText);
    // print timings from previous frame
    f32 DebugFontScale = stbtt_ScaleForPixelHeight(&State->Font, 22.f);
    text_printer DebugPrinter =
        TextPrinter(State, &RenderQueue, V2(200.f, State->Camera.Dim.y - UiLineHeight*2), UiLineHeight, DebugFontScale, -1, 40, Colors[CT_Highlight]);
    for(u32 TimingIndex = TimingCount - 1;
        TimingIndex != 0;
        --TimingIndex)
    {
        timing *Timing = PreviousFrameTimings + TimingIndex;
        if(Timing->CallCount > 0)
        {
            //char Buffer[1024];
            //if(Timing->CallCount > 1)
            //{
            //    sprintf(Buffer, "%s: %d calls, %9lld cycles, %10f sec on average (%9lld cycles, %10f sec in total)",
            //            Timing->Name, Timing->CallCount, Timing->Cycles / Timing->CallCount, Timing->Seconds / (f32)Timing->CallCount,
            //            Timing->Cycles, Timing->Seconds);
            //}
            //else
            //{
            //    sprintf(Buffer, "%s: %9lld cycles, %10f sec in total", Timing->Name, Timing->Cycles, Timing->Seconds);
            //}
            //PrintText(&DebugPrinter, Buffer);
            v2 RectangleBottomLeft = V2(0.f, DebugPrinter.Position.y);
            v2 RectangleDim = V2(200.f * (Timing->Seconds / TimeForFrame), UiLineHeight * .25f);
            DebugDrawRect(V2(RectangleBottomLeft.x + .5f * RectangleDim.x,
                             RectangleBottomLeft.y + .5f * RectangleDim.y),
                          RectangleDim, V3(Timing->Seconds / TimeForFrame,
                                           (TimeForFrame - Timing->Seconds) / TimeForFrame,
                                           0.f));
            PrintText(&DebugPrinter, Timing->Name);
            PrintNewline(&DebugPrinter);
        }
    }
    TextPass();
    EndTiming(DrawingDebugText);
#else
#endif

    if(GlobalDebugQueue.SquareCount)
    {
        UseShader(SP_Debug);
        glBindVertexArray(GlobalDebugQueue.VAO);
        {
            glBindBuffer(GL_ARRAY_BUFFER, GlobalDebugQueue.VBO);
            glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(square)*GlobalDebugQueue.SquareCount, GlobalDebugQueue.Squares);

            glDrawArrays(GL_POINTS, 0, GlobalDebugQueue.SquareCount);
        }
    }
    EndTiming(DebugPass);
#endif

    if(RenderQueue.BackgroundCount)
    {
        glBindVertexArray(State->TextBackgroundVAO);
        glBindBuffer(GL_ARRAY_BUFFER, State->TextBackgroundVBO);
        glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(text_background)*RenderQueue.BackgroundCount, RenderQueue.Backgrounds);
        UseShader(SP_TextBackground);
        glDrawArraysInstanced(GL_TRIANGLE_STRIP, 0, 4, RenderQueue.BackgroundCount);
    }
    if(RenderQueue.CharacterCount)
    {
        glBindVertexArray(State->TextVAO);
        glBindBuffer(GL_ARRAY_BUFFER, State->TextVBO);
        glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(ui_text_display_data)*RenderQueue.CharacterCount, RenderQueue.Characters);
        UseShader(SP_Text);
        glDrawArraysInstanced(GL_TRIANGLE_STRIP, 0, 4, RenderQueue.CharacterCount);
    }

    EndTiming(Rendering);

    // frame end
    StartTiming(ResetLocking);
    for(u32 CellIndex = UiCharacterCount;
        CellIndex < TACellCount;
        ++CellIndex)
    {
        ta_cell *Cell = State->TA.Cells + CellIndex;
        Cell->IsLocked = false;
    }
    EndTiming(ResetLocking);

    if(BookmarksChanged)
    {
        size_t CacheSize = sizeof(reference_cache_header) + sizeof(rect)*State->WordCount*ReferenceLayerCount;
        Platform.WriteFile(Memory->CachePath, CacheSize, State->ReferenceHeader);
    }

    State->LastFrameTime = Input->Time;
    State->LastFrameMousePos = MousePos;
    ResetArena(FrameArena);

#if DEBUG_INFO
    GlobalDebugQueue.SquareCount = 0;
    StartTiming(CopyingPreviousTimings);
    for(u32 TimingIndex = 0; TimingIndex < TimingCount; ++TimingIndex)
    {
        PreviousFrameTimings[TimingIndex] = GlobalTimings[TimingIndex];
        GlobalTimings[TimingIndex] = (timing){0};
    }
    EndTiming(CopyingPreviousTimings);
#endif

    EndTimingFunc();
}

// IMPORTANT NOTE: do not put anything past this line
u32 GlobalDebugTimingCount = __COUNTER__;
